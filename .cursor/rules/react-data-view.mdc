---
description: how to migrate components using TableToolbarView to react-data-view
alwaysApply: false
---
### Step 3: Create New TypeScript Component with react-data-view

**Goal**: Build a modern TypeScript component using PatternFly's react-data-view patterns.

**Process**:
1. **Create new `.tsx` file** alongside the existing `.js` file
2. **Implement react-data-view patterns** based on learned best practices
3. **Use proper TypeScript types** throughout
4. **Follow established DataView patterns**:

**Component Structure Template**:
```tsx
// NewComponent.tsx
import React, { Fragment, Suspense, useCallback, useEffect, useMemo } from 'react';
import { shallowEqual, useDispatch, useSelector } from 'react-redux';
import { Outlet, useParams } from 'react-router-dom';
import { useIntl } from 'react-intl';

// DataView imports
import { DataView, DataViewState } from '@patternfly/react-data-view';
import { DataViewToolbar } from '@patternfly/react-data-view/dist/dynamic/DataViewToolbar';
import { DataViewTable } from '@patternfly/react-data-view/dist/dynamic/DataViewTable';
import { DataViewTextFilter } from '@patternfly/react-data-view';
import DataViewFilters from '@patternfly/react-data-view/dist/cjs/DataViewFilters';

// Component-specific imports
import { ComponentEmptyState } from './components/ComponentEmptyState';
import { useComponentData } from './useComponentData';
import type { ComponentFilters, ComponentItem, ComponentTableRow } from './types';

interface ComponentProps {
  // Define props interface
}

const Component: React.FC<ComponentProps> = () => {
  const intl = useIntl();
  const dispatch = useDispatch();
  const navigate = useAppNavigate();
  const { id } = useParams<{ id: string }>();

  // Use custom hook for ALL business logic
  const {
    items,
    isLoading,
    totalCount,
    isAdmin,
    filters,
    selection,
    pagination,
    tableRows,
    columns,
    fetchData,
    handleDelete,
    emptyStateProps,
    // ... other business logic
  } = useComponentData({ defaultPerPage: 20 });

  // Component-specific logic only (navigation, etc.)
  const handleRowClick = useCallback((item: ComponentItem) => {
    navigate(`/path/${item.id}`);
  }, [navigate]);

  // Skeleton states
  const loadingHeader = <SkeletonTableHead columns={columns.map(col => col.cell)} />;
  const loadingBody = <SkeletonTableBody rowsCount={10} columnsCount={columns.length} />;

  // Empty state
  const emptyState = <ComponentEmptyState {...emptyStateProps} />;

  // Determine active state
  const activeState = isLoading ? DataViewState.loading : items.length === 0 ? DataViewState.empty : undefined;

  return (
    <Fragment>
      <DataView activeState={activeState} selection={isAdmin ? selection : undefined}>
        <DataViewToolbar
          bulkSelect={isAdmin ? bulkSelectComponent : undefined}
          pagination={paginationComponent}
          filters={
            <DataViewFilters onChange={handleFilterChange} values={filters.filters}>
              <DataViewTextFilter filterId="name" title="Name" placeholder="Filter by name" />
            </DataViewFilters>
          }
          clearAllFilters={filters.clearAllFilters}
          actions={actionsComponent}
        />
        <DataViewTable
          columns={columns}
          rows={tableRows}
          headStates={{ loading: loadingHeader }}
          bodyStates={{
            loading: loadingBody,
            empty: emptyState,
          }}
          onRowClick={onRowClick}
        />
        <DataViewToolbar
          pagination={footerPaginationComponent}
        />
      </DataView>
      <Suspense fallback={<div>Loading...</div>}>
        <Outlet />
      </Suspense>
    </Fragment>
  );
};

export default Component;
```

**Key Patterns to Follow**:
- **DataView Structure**: Always use the three-part structure (toolbar + table + footer toolbar)
- **State Management**: Use `DataViewState` for loading/empty states
- **Selection**: Only enable for admin users when applicable
- **Skeleton Loading**: Use PatternFly skeleton components
- **Empty States**: Extract to separate components

---

### Step 4: Create Custom Hooks for Business Logic

**Goal**: Extract ALL business logic into reusable, well-typed custom hooks.

**Process**:
1. **Create `useComponentName.ts` hook** in `hooks/` subdirectory
2. **Extract all business logic** from the original component
3. **Use proper TypeScript typing** leveraging existing Redux types
4. **Don't trust reducer types 100%** - the JS component is the source of truth
5. **Return comprehensive interface** with all necessary data and actions

**Hook Template**:
```tsx
// hooks/useComponentData.ts
import { useCallback, useContext, useMemo, useState } from 'react';
import { shallowEqual, useDispatch, useSelector } from 'react-redux';
import { useParams, useSearchParams } from 'react-router-dom';
import { useIntl } from 'react-intl';
import { useDataViewFilters, useDataViewPagination, useDataViewSelection } from '@patternfly/react-data-view';

// Types
import type { ComponentFilters, ComponentItem, ComponentTableRow, SortByState } from './types';
import type { RBACStore } from '../../../redux/store';

// Options interface
interface UseComponentDataOptions {
  defaultPerPage?: number;
  enableAdminFeatures?: boolean;
}

// Return interface - be comprehensive!
export interface UseComponentDataReturn {
  // Core data
  items: ComponentItem[];
  isLoading: boolean;
  totalCount: number;
  
  // Permissions & state
  isAdmin: boolean;
  
  // DataView hooks (expose the hook objects directly)
  filters: ReturnType<typeof useDataViewFilters>;
  selection: ReturnType<typeof useDataViewSelection>;
  pagination: ReturnType<typeof useDataViewPagination>;
  
  // Computed values
  hasActiveFilters: boolean;
  tableRows: ComponentTableRow[];
  columns: Array<{ cell: string }>;
  
  // Actions
  fetchData: (filterValue?: string, apiProps?: Record<string, any>) => void;
  handleDelete: (items: ComponentItem[]) => Promise<any>;
  
  // Empty state props
  emptyStateProps: {
    colSpan: number;
    hasActiveFilters: boolean;
    titleText?: string;
  };
  
  // Other business logic...
}

export const useComponentData = (options: UseComponentDataOptions = {}): UseComponentDataReturn => {
  const { defaultPerPage = 20, enableAdminFeatures = false } = options;
  
  const intl = useIntl();
  const dispatch = useDispatch();
  const [searchParams, setSearchParams] = useSearchParams();
  const { id } = useParams<{ id: string }>();
  
  // DataView hooks
  const filters = useDataViewFilters<ComponentFilters>({
    initialFilters: { name: '', email: '' },
  });
  
  const selection = useDataViewSelection({
    matchOption: (a, b) => a.id === b.id,
  });
  
  const pagination = useDataViewPagination({
    perPage: defaultPerPage,
    searchParams,
    setSearchParams,
  });
  
  // Redux selectors (use proper selectors, don't trust types completely)
  const items = useSelector((state: RBACStore) => 
    state.groupReducer?.selectedGroup?.members || [], shallowEqual
  );
  const isLoading = useSelector((state: RBACStore) => 
    state.groupReducer?.isLoading || false, shallowEqual
  );
  const totalCount = useSelector((state: RBACStore) => 
    state.groupReducer?.selectedGroup?.members_meta?.count || 0, shallowEqual
  );
  
  // Permissions
  const { isOrgAdmin } = useContext(PermissionsContext);
  const isAdmin = enableAdminFeatures && isOrgAdmin;
  
  // Business logic functions
  const fetchData = useCallback((filterValue?: string, apiProps: Record<string, any> = {}) => {
    const params = {
      uuid: id,
      orderBy: 'username',
      filters: filters.filters,
      ...pagination,
      ...apiProps,
    };
    dispatch(fetchMembersForGroup(params));
  }, [dispatch, id, filters.filters, pagination]);
  
  const handleDelete = useCallback(async (membersToDelete: ComponentItem[]) => {
    const usernames = membersToDelete.map(member => member.username);
    await dispatch(removeMembersFromGroup(id!, usernames));
    selection.onSelect(false); // Clear selection after action
    fetchData(); // Refresh data
  }, [dispatch, id, selection, fetchData]);
  
  // Table rows generation
  const tableRows = useMemo((): ComponentTableRow[] => {
    return items.map((item): ComponentTableRow => ({
      id: item.username,
      row: [
        selection.isSelected(item),
        item.username,
        item.email || '',
        item.last_name || '',
        item.first_name || '',
        // Actions column handled in component
      ],
      item,
    }));
  }, [items, selection]);
  
  // Columns definition
  const columns = useMemo(() => [
    { cell: intl.formatMessage(messages.username) },
    { cell: intl.formatMessage(messages.email) },
    { cell: intl.formatMessage(messages.lastName) },
    { cell: intl.formatMessage(messages.firstName) },
    { cell: '' }, // Actions column
  ], [intl]);
  
  // Computed values
  const hasActiveFilters = Object.values(filters.filters).some(value => value !== '');
  
  // Empty state props
  const emptyStateProps = {
    colSpan: columns.length,
    hasActiveFilters,
    titleText: intl.formatMessage(messages.noMembers),
  };
  
  // Return comprehensive interface
  return {
    items,
    isLoading,
    totalCount,
    isAdmin,
    filters,
    selection,
    pagination,
    hasActiveFilters,
    tableRows,
    columns,
    fetchData,
    handleDelete,
    emptyStateProps,
  };
};
```

**Key Principles**:
- **Single Source of Truth**: The original JS component logic is authoritative
- **Comprehensive Interface**: Return everything the component needs
- **Proper Typing**: Use TypeScript but validate against JS behavior
- **DataView Integration**: Expose DataView hooks directly for flexibility
- **Action Side Effects**: Handle selection clearing, data refresh automatically

---

### Step 5: Copy and Adapt Stories for New Component

**Goal**: Migrate test coverage to the new component with minimal story changes.

**Process**:
1. **Copy existing stories** to new component story file
2. **Update component import** to use new TypeScript component
3. **Update selectors** where the DOM structure has changed
4. **Focus on fixing the component** when tests fail, not the stories
5. **Minimize story changes** - they should test the same behavior
6. **Use same mock data** and scenarios

**Story Migration Example**:
```tsx
// NewComponent.stories.tsx (copied from ExistingComponent.stories.tsx)
import type { Meta, StoryObj } from '@storybook/react-webpack5';
import { expect, fn, userEvent, within } from 'storybook/test';

// ONLY change: import the new component
import { NewComponent } from './NewComponent';

// Keep all the same mock data
const mockStore = /* same as before */;

const meta: Meta<typeof NewComponent> = {
  title: 'Features/Groups/NewComponent', // Update title
  component: NewComponent, // Update component reference
  // Keep same decorators, parameters, etc.
  decorators: [/* same as before */],
  parameters: {/* same as before */},
};

export default meta;
type Story = StoryObj<typeof NewComponent>;

// Keep all the same stories with same data
export const Default: Story = {/* same args */};
export const WithData: Story = {/* same args */};
export const Loading: Story = {/* same args */};

// Update play functions ONLY if selectors need to change
export const FilteringAndSorting: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Update selectors only if necessary
    // OLD: const filterInput = await canvas.findByRole('textbox');
    // NEW: const filterInput = await canvas.findByRole('textbox');
    const filterInput = await canvas.findByRole('textbox');
    await userEvent.type(filterInput, 'test');
    
    // Keep same test logic
    const sortableHeader = await canvas.findByText('Name');
    await userEvent.click(sortableHeader);
    
    // Keep same assertions
    expect(/* same assertions */);
  },
};
```

**Story Adaptation Guidelines**:
- **Minimal Changes**: Change imports and selectors only
- **Same Test Logic**: Keep the same user interactions and assertions
- **Focus on Component**: If tests fail, fix the component, not the story
- **Preserve Coverage**: Ensure all scenarios are still tested
- **DOM Changes**: Update selectors only when DataView structure differs

---

### Step 6: Remove Old Component and Update Imports

**Goal**: Clean up after successful migration and ensure no broken references.

**Process**:
1. **Verify all stories pass** in the new component
2. **Run full test suite** to ensure no regressions
3. **Search for all imports** of the old component
4. **Update all import references** to use new component
5. **Remove the old component file**
6. **Update any route definitions** if needed
7. **Clean up unused dependencies**

**Import Update Process**:
```bash
# 1. Find all references to old component
grep -r "import.*OldComponent" src/

# 2. Update each import to new component
# OLD: import OldComponent from '../path/OldComponent';
# NEW: import { NewComponent } from '../path/NewComponent';

# 3. Update component usage if name changed
# OLD: <OldComponent />
# NEW: <NewComponent />

# 4. Check route definitions
grep -r "OldComponent" src/App.js src/routes/

# 5. Remove old file
rm src/path/OldComponent.js
```

**Validation Checklist**:
- [ ] All Storybook stories pass
- [ ] No TypeScript compilation errors
- [ ] No linting errors
- [ ] All existing functionality preserved
- [ ] No broken imports in codebase
- [ ] Routes still work correctly
- [ ] No console errors in browser/Storybook

---

## Common DataView Patterns

### Standard Component Structure
```tsx
// Most DataView components follow this pattern:
<DataView activeState={activeState} selection={isAdmin ? selection : undefined}>
  <DataViewToolbar
    bulkSelect={bulkSelectComponent}
    pagination={topPaginationComponent}
    filters={filtersComponent}
    clearAllFilters={clearAllFilters}
    actions={actionsComponent}
  />
  <DataViewTable
    columns={columns}
    rows={tableRows}
    headStates={{ loading: loadingHeader }}
    bodyStates={{
      loading: loadingBody,
      empty: emptyState,
    }}
    onRowClick={onRowClick}
  />
  <DataViewToolbar
    pagination={footerPaginationComponent}
  />
</DataView>
```

### Compound Expandable Table Pattern

**Important**: For compound expandable tables, you CANNOT use `DataViewTable`. You must create a custom table component using raw PatternFly Table components.

```tsx
// Custom table component for compound expansion
const TableContent: React.FC<{
  items: Item[];
  expandedCells: Record<string, string>;
  setExpandedCells: (cells: Record<string, string>) => void;
  columns: Array<{ title: string; key?: string }>;
  sortByState: SortByState;
  onSort: (event: any, index: number, direction: 'asc' | 'desc') => void;
  // ... other props
}> = ({ items, expandedCells, setExpandedCells, columns, sortByState, onSort }) => {
  const intl = useIntl();

  const setCellExpanded = (item: Item, columnKey: string, isExpanding = true) => {
    const newExpandedCells = { ...expandedCells };
    if (isExpanding) {
      newExpandedCells[item.id] = columnKey;
      // Fetch additional data when expanding if needed
    } else {
      delete newExpandedCells[item.id];
    }
    setExpandedCells(newExpandedCells);
  };

  const compoundExpandParams = (item: Item, columnKey: string, rowIndex: number, columnIndex: number) => ({
    isExpanded: expandedCells[item.id] === columnKey,
    onToggle: () => setCellExpanded(item, columnKey, expandedCells[item.id] !== columnKey),
    expandId: 'compound-expansion',
    rowIndex,
    columnIndex,
  });

  const getSortParams = (columnIndex: number) => ({
    sort: {
      sortBy: {
        index: sortByState.index,
        direction: sortByState.direction,
      },
      onSort,
      columnIndex,
    },
  });

  return (
    <Table isExpandable aria-label={intl.formatMessage(messages.items)}>
      <Thead>
        <Tr>
          <Th {...(columns[0].key ? getSortParams(0) : {})}>{columns[0].title}</Th>
          <Th>{columns[1].title}</Th>
          <Th>{columns[2].title}</Th>
        </Tr>
      </Thead>
      {items.map((item, rowIndex) => {
        const expandedCellKey = expandedCells[item.id];
        const isRowExpanded = !!expandedCellKey;

        return (
          <Tbody key={item.id} isExpanded={isRowExpanded}>
            <Tr>
              <Td dataLabel={columns[0].title} component="th">
                {item.name}
              </Td>
              <Td dataLabel={columns[1].title}>{item.description}</Td>
              <Td 
                dataLabel={columns[2].title} 
                compoundExpand={compoundExpandParams(item, 'details', rowIndex, 2)}
              >
                {item.count}
              </Td>
            </Tr>

            <Tr isExpanded={isRowExpanded && expandedCellKey === 'details'}>
              <Td dataLabel="Details" noPadding colSpan={3}>
                <ExpandableRowContent>
                  <NestedTable item={item} />
                </ExpandableRowContent>
              </Td>
            </Tr>
          </Tbody>
        );
      })}
    </Table>
  );
};

// Main component with DataView wrapper
<DataView activeState={activeState}>
  <DataViewToolbar
    filters={filtersComponent}
    clearAllFilters={clearAllFilters}
  />
  {/* Manual state handling for compound expansion */}
  {isLoading ? (
    <Table aria-label="Loading">
      {loadingHeader}
      {loadingBody}
    </Table>
  ) : filteredItems.length === 0 ? (
    <Table aria-label="Empty">
      <Thead>
        <Tr>
          {columns.map((column, index) => (
            <Th key={index}>{column.title}</Th>
          ))}
        </Tr>
      </Thead>
      {emptyStateComponent}
    </Table>
  ) : (
    <TableContent
      items={filteredItems}
      expandedCells={expandedCells}
      setExpandedCells={setExpandedCells}
      columns={columns}
      sortByState={sortByState}
      onSort={handleSort}
    />
  )}
</DataView>
```

**Key Requirements for Compound Expandable Tables**:
- **Custom Table Component**: Create separate component using Table, Thead, Tbody, Tr, Td
- **Manual State Management**: Handle expansion state with local state object
- **Compound Expand Props**: Use `compoundExpand` prop on expandable `Td` elements
- **Manual Rendering**: Handle loading, empty, and data states manually
- **DataView Wrapper**: Still use DataView for toolbar and overall state management
- **No DataViewTable**: Cannot use DataViewTable - must use raw PatternFly Table components

### Filter Pattern
```tsx
const filters = useDataViewFilters({
  initialFilters: { name: '', email: '' },
});

const handleFilterChange = useCallback(
  (_event: any, newFilters: Filters) => {
    filters.onSetFilters(newFilters);
    debouncedFetchData(newFilters, { offset: 0 });
  },
  [filters, debouncedFetchData],
);

// In JSX:
<DataViewFilters onChange={handleFilterChange} values={filters.filters}>
  <DataViewTextFilter filterId="name" title="Name" placeholder="Filter by name" />
  <DataViewTextFilter filterId="email" title="Email" placeholder="Filter by email" />
</DataViewFilters>
```

### Selection Pattern
```tsx
const selection = useDataViewSelection({
  matchOption: (a, b) => a.id === b.id,
});

const handleBulkSelect = useCallback(
  (value: BulkSelectValue) => {
    if (value === BulkSelectValue.none) {
      selection.onSelect(false);
    } else if (value === BulkSelectValue.page) {
      // Select all items on current page
      selection.onSelect(true, tableRows);
    } else if (value === BulkSelectValue.nonePage) {
      // Deselect all items on current page
      selection.onSelect(false, tableRows);
    }
  },
  [selection, tableRows],
);

// BulkSelect component configuration
const bulkSelectComponent = useMemo(() => {
  if (!hasPermissions) {
    return undefined;
  }

  const selectedCount = selection.selected?.length || 0;
  const currentPageCount = items.length; // Items on current page
  const totalCount = pagination.count || 0; // Total items across all pages

  // Calculate if all/some items on current page are selected
  const selectedOnPage = tableRows.filter((row) => selection.selected?.some((sel) => sel.id === row.id)).length;
  const pageSelected = selectedOnPage > 0 && selectedOnPage === currentPageCount;
  const pagePartiallySelected = selectedOnPage > 0 && selectedOnPage < currentPageCount;

  return (
    <BulkSelect
      isDataPaginated={true}
      selectedCount={selectedCount}
      totalCount={totalCount}
      pageCount={currentPageCount}
      pageSelected={pageSelected}
      pagePartiallySelected={pagePartiallySelected}
      onSelect={handleBulkSelect}
    />
  );
}, [hasPermissions, selection.selected, items.length, pagination.count, tableRows, handleBulkSelect]);

// IMPORTANT: Do NOT use canSelectAll={true}
// useDataViewSelection doesn't support cross-page "select all" - it only works with items you pass to it
// BulkSelectValue.page is the correct option for selecting all on the current page

// Clear selection after actions
const handleDelete = useCallback(async (items) => {
  await deleteAction(items);
  selection.onSelect(false); // Important!
  fetchData();
}, [selection, fetchData]);
```



---

## Troubleshooting Common Issues

### 1. Infinite Re-renders
**Problem**: Including objects in dependency arrays
**Solution**: Use `shallowEqual` in useSelector, properly memoize objects

```tsx
// BAD
const items = useSelector(state => state.items);

// GOOD
const items = useSelector(state => state.items, shallowEqual);
```

### 2. Selection Not Clearing
**Problem**: Forgetting to clear selection after actions
**Solution**: Always call `selection.onSelect(false)` after bulk actions

### 3. Table Layout Issues
**Problem**: Empty states not rendering in table context
**Solution**: Always wrap empty states in `<tbody><tr><td colSpan={n}>` (see Step 2)

### 4. Filter State Issues
**Problem**: Filters causing unnecessary re-renders
**Solution**: Use `useDataViewFilters` hook properly, debounce API calls

### 5. TypeScript Errors
**Problem**: DataView hook types not fully defined
**Solution**: Use `any` for hook types when needed, focus on functionality

---

## File Organization

```
src/features/[feature]/
├── components/
│   ├── [Component]EmptyState.tsx      # Step 2: Extracted empty state
│   ├── [Component]EmptyState.stories.tsx
│   └── [Other]Components.tsx
├── hooks/
│   └── use[Component].ts              # Step 4: Business logic hook
├── [Component].tsx                    # Step 3: New DataView version
├── [Component].stories.tsx            # Step 5: Migrated stories
├── [component].js                     # Legacy (remove in Step 6)
├── types.ts                          # TypeScript interfaces
└── index.ts                          # Export file
```

---

## Success Criteria

A successful migration achieves:

### Functional Requirements
- [ ] All original functionality preserved
- [ ] Same user experience and interactions
- [ ] Proper error handling and edge cases
- [ ] Internationalization maintained
- [ ] Accessibility preserved

### Technical Requirements
- [ ] TypeScript compilation with no errors
- [ ] All Storybook stories pass
- [ ] No linting errors
- [ ] Proper separation of concerns (hooks)
- [ ] Consistent code patterns
- [ ] No performance regressions

### Testing Requirements
- [ ] Comprehensive Storybook coverage
- [ ] All business logic scenarios tested
- [ ] Interactive testing with play functions
- [ ] Empty state testing
- [ ] Permission scenario coverage

This process ensures consistent, maintainable, and well-tested component migrations that follow modern React patterns and PatternFly design standards.