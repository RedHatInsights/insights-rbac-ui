---
type: required
description: "Storybook story development guidelines including component documentation, user interaction testing, play functions, feature flag handling, and story organization standards."
patterns:
  - "**/*.stories.tsx"
  - "**/*.stories.ts"
tags:
  - storybook
priority: critical
---

# MANDATORY Storybook Development Guidelines
## üö® CRITICAL ENFORCEMENT RULES (AI MUST FOLLOW) 

**‚ö†Ô∏è NEVER IGNORE THESE RULES FOR .stories.tsx FILES ‚ö†Ô∏è**

### ABSOLUTE REQUIREMENTS FOR ALL .stories.tsx FILES
1. **IMPORT RULE**: `import { userEvent, within, expect, fn, waitFor } from 'storybook/test';` - NEVER from @storybook/test
2. **QUERY RULE**: Use `await canvas.findByText()` - NEVER `canvas.getByText()` in play functions
3. **MODAL RULE**: Use `screen.getByRole('dialog')` - Modals render to document.body, NOT canvas
4. **AWAIT RULE**: ALWAYS `await expect(...)` in play functions for Interactions panel
5. **CONTAINER RULE**: Single autodocs pattern - meta has NO autodocs, default story ONLY
6. **MSW RULE**: Use MSW handlers - NEVER storeState for container stories
7. **ARGS RULE**: Only remove `args` parameter if story doesn't use it
8. **API SPY RULE**: For container stories - ALWAYS use `const apiSpy = fn()` + call in MSW handlers + test with `expect(apiSpy).toHaveBeenCalled()`
9. **REACT-DATA-VIEW RULE**: Use exact patterns - BulkSelect from react-component-groups, useDataViewSelection with matchOption, conditional selection prop

## Quick Reference (AI Priority)

### Story Types & Patterns
| Component Type | Meta Tags | Default Story | Other Stories |
|---------------|-----------|---------------|---------------|
| Presentational | `['autodocs']` | Standard story | Standard stories |
| Container | `['container-name']` | `tags: ['autodocs']` + directory | MSW only, no docs |

### Container Story Checklist
- [ ] Meta: NO autodocs tag (`tags: ['container-name']`)
- [ ] Default story: `tags: ['autodocs']` + story directory links
- [ ] All stories: MSW handlers (NEVER `storeState`)
- [ ] Test real API orchestration, not pre-populated Redux

### Critical Rules
| Rule | Presentational | Container |
|------|---------------|-----------|
| API Testing | Props/args | MSW handlers |
| Redux Testing | N/A | Real orchestration |
| Autodocs | All stories | Default only |
| MSW Conflicts | Rare | Prevented by single autodocs |

### Testing Imports (REQUIRED)
```typescript
import { userEvent, within, expect, fn, waitFor } from 'storybook/test';
// NEVER: @storybook/test or individual packages

‚ö†Ô∏è **ALWAYS** `await` your `expect` calls inside a play function:
```typescript
await expect(canvas.findByText('Save')).resolves.toBeInTheDocument();
```
This is required so that results appear correctly in Storybook‚Äôs **Interactions** panel and so the test runner can report assertion failures reliably.
```

### Modal Testing Pattern
```typescript
// ‚úÖ Modals render to document.body (portal)
const modal = screen.getByRole('dialog');  // NOT canvas.getByRole
expect(within(modal).getByText('Title')).toBeInTheDocument();
```


## Storybook Configuration Overview

Our Storybook setup uses **Storybook 9.x** with React and Webpack 5, providing a comprehensive development and testing environment.

### Core Configuration
- **Framework**: `@storybook/react-webpack5` with SWC compiler for fast builds
- **Stories Location**: All `*.stories.@(js|jsx|mjs|ts|tsx)` files under `src/` directory
- **Documentation**: MDX files supported in `src/docs/` and throughout the project
- **Static Assets**: Served from `./static` directory

### Key Addons & Features
- **@storybook/addon-docs**: Automatic documentation generation with `tags: ['autodocs']`
- **@storybook/addon-webpack5-compiler-swc**: Fast compilation using SWC
- **msw-storybook-addon**: API mocking capabilities for realistic story testing
- **MSW Integration**: Automatically initialized for all stories with `mswLoader`

### Development Context Providers
All stories are automatically wrapped with essential context providers:
- **IntlProvider**: Internationalization with locale data from `src/locales/data.json`
- **PermissionsContext**: User access control simulation
- **ChromeProvider**: Red Hat Cloud Services chrome environment simulation
- **FeatureFlagsProvider**: Feature flag testing capabilities

### Default Story Parameters
Every story automatically inherits these default configurations:
```typescript
parameters: {
  actions: { argTypesRegex: '^on.*' }, // Auto-detect event handlers
  permissions: {
    userAccessAdministrator: false,
    orgAdmin: false,
  },
  chrome: {
    environment: 'prod',
  },
  featureFlags: {
    'platform.rbac.itless': false,
  },
}
```

### Custom Webpack Configuration
- **SCSS Support**: Automatic compilation of `.scss` files with style-loader, css-loader, and sass-loader
- **Hook Mocking**: Development-specific versions of Red Hat hooks:
  - `@redhat-cloud-services/frontend-components/useChrome` ‚Üí `.storybook/hooks/useChrome`
- `@unleash/proxy-client-react` ‚Üí `.storybook/hooks/unleash`

### TypeScript Integration
- **react-docgen-typescript**: Automatic prop documentation generation
- **Type Safety**: Full TypeScript support with component type extraction
- **Prop Filtering**: Excludes node_modules props from documentation

### Testing Configuration
- **Test Runner**: `@storybook/test-runner` with custom configuration
- **Timeout**: 20 seconds for slower interactive stories
- **Error Detection**: Automatic console error checking after each story
- **Skip Tags**: Stories tagged with `skip-test` are excluded from test runs
- **MSW Integration**: API mocking works seamlessly in test environment

### Custom Styling
- **PatternFly Integration**: Core CSS automatically loaded (`@patternfly/react-core/dist/styles/base.css`)
- **Custom Theme**: Enhanced styling in `.storybook/storybook.css` with:
  - Improved documentation layout and typography
  - Dark mode support with `prefers-color-scheme`
  - Responsive design for mobile viewing
  - Enhanced code block and table styling
  - Accessibility focus improvements
  - Print-friendly styles

### Interactive Controls & Args
Stories can override default context values through args:
- `orgAdmin`, `userAccessAdministrator`: Permission controls
- `environment`: Chrome environment simulation
- Feature flag controls: Direct boolean controls for testing different states

## Story Development Principles

### Focus on the Component, Not Wrappers
- Stories should document the **actual component** being developed, not wrappers
- Set `component: ActualComponent` in meta object
- Avoid complex wrapper components like `TableToolbarView` in stories

### Title Generation (FORBIDDEN)
- **NEVER** use custom `title` in meta configuration
- **ALWAYS** let Storybook's automatic title generation do the work
- Automatic titles are generated from file paths and are consistent across the project

### File Naming Requirements
- Component files: `ComponentName.tsx` (MUST be capitalized and reflect component name)
- Story files: `ComponentName.stories.tsx` (MUST be capitalized and reflect component name)

### Story Requirements (MANDATORY)
- **REQUIRED**: All **presentational component** stories MUST use `tags: ['autodocs']` by default
- **REQUIRED**: All user interactions in components MUST have play functions to test them
- Stories must test actual user workflows, not just trigger events
- Cover all interactive states: hover, focus, disabled, error, etc.

### Story Tagging Requirements (MANDATORY)

**CRITICAL**: All stories MUST include appropriate metadata tags to enable filtering and categorization in Storybook UI.

#### Required Tag Types

1. **Feature Flag Tags** (`ff:*`)
   - **REQUIRED** for any story that sets feature flags via `parameters.featureFlags` or `args`
   - Format: `ff:full.feature.flag.name`
   - Examples: `ff:platform.rbac.itless`, `ff:platform.rbac.workspaces`, `ff:platform.rbac.groups`
   ```typescript
   export const StoryWithFlags: Story = {
     tags: ['ff:platform.rbac.itless', 'ff:platform.rbac.workspaces'],
     parameters: {
       featureFlags: {
         'platform.rbac.itless': true,
         'platform.rbac.workspaces': true,
       },
     },
   };
   ```

2. **Environment Tags** (`env:*`)
   - **REQUIRED** for any story that sets `chrome.environment` parameter
   - Format: `env:environment-name`
   - Common values: `env:prod`, `env:stage`, `env:ci-beta`
   ```typescript
   export const ProductionStory: Story = {
     tags: ['env:prod'],
     parameters: {
       chrome: { environment: 'prod' },
     },
   };
   ```

3. **Permission Tags** (`perm:*`)
   - **REQUIRED** for any story that sets permissions to `true` via `parameters.permissions` or `args`
   - Only tag when permission is explicitly `true` (default is `false`)
   - Tags: `perm:org-admin` for `orgAdmin: true`, `perm:user-access-admin` for `userAccessAdministrator: true`
   - Tag placement: Apply at meta level if permissions are in meta parameters, or at story level if in story parameters/args
   ```typescript
   // Story-level permissions ‚Üí story-level tags
   export const AdminStory: Story = {
     tags: ['env:stage', 'perm:org-admin', 'perm:user-access-admin'],
     parameters: {
       chrome: { environment: 'stage' },
       permissions: { 
         orgAdmin: true, 
         userAccessAdministrator: true 
       },
     },
   };
   
   // Meta-level permissions ‚Üí meta-level tags
   const meta: Meta<typeof Component> = {
     component: Component,
     tags: ['autodocs', 'perm:org-admin'],
     parameters: {
       permissions: { orgAdmin: true },
     },
   };
   ```

4. **Custom CSS Tags** (`custom-css`)
   - **REQUIRED** for any component that imports `.scss` files
   - Check the component file (not the story file) for CSS imports
   - Tag: `custom-css`
   ```typescript
   // If component imports './Component.scss'
   const meta: Meta<typeof Component> = {
     component: Component,
     tags: ['autodocs', 'custom-css'],
   };
   ```

#### Tag Application Rules

- **Meta-level tags**: Apply to all stories in the file
  ```typescript
  const meta: Meta<typeof Component> = {
    component: Component,
    tags: ['autodocs', 'ff:platform.rbac.workspaces', 'custom-css'],
  };
  ```

- **Story-level tags**: Apply to individual stories, merge with meta tags
  ```typescript
  export const AdminProduction: Story = {
    tags: ['env:prod', 'perm:org-admin'], // Merges with meta tags
    parameters: {
      chrome: { environment: 'prod' },
      permissions: { orgAdmin: true },
    },
  };
  ```

#### Tag Naming Conventions

- **Use full flag names**: `ff:platform.rbac.itless` not `ff:itless`
- **Use lowercase with hyphens**: `perm:org-admin` not `perm:orgAdmin`
- **Be specific**: `env:stage` not `env:staging`
- **No test-targeting tags**: Don't add internal tags (removed: `test-spy`, `production-bug`, `modal-testing`, `filtering-pagination`, `workspaces`, `users-container`, `roles-container`, `access-management-container`, etc.)

#### Tag Verification Checklist

Before submitting stories, verify:
- [ ] All feature flags have `ff:*` tags with full flag names
- [ ] All environment settings have `env:*` tags
- [ ] All `true` permissions have `perm:*` tags
- [ ] Components with CSS imports have `custom-css` tag
- [ ] No internal/test-targeting tags remain in code

**WHY THIS MATTERS**: These tags enable developers to quickly filter and find relevant stories in Storybook UI based on feature flags, environments, permissions, and styling requirements.

### Container Story Requirements (SPECIAL PATTERN)
- **Container stories** with multiple stories should use **single autodocs pattern**:
  - Remove `autodocs` from meta (NO autodocs on meta)
  - Add `autodocs` only to default story: `tags: ['autodocs']`
  - Default story must include comprehensive directory of all other stories with clickable links
  - Apply appropriate `ff:*`, `env:*`, `perm:*`, and `custom-css` tags to meta or individual stories as needed
- **NEVER** use `storeState` to pre-populate Redux in container stories
- **NEVER** add internal test-targeting tags (removed: `workspaces`, `users-container`, `roles-container`, etc.)
- **ALWAYS** use real API orchestration with MSW handlers for container testing

### Story Structure Template

#### Presentational Component Template
```typescript
const meta: Meta<typeof ComponentName> = {
  component: ComponentName,  // The actual component being documented
  tags: ['autodocs'],       // REQUIRED: Presentational components use autodocs tag
  parameters: {
    docs: {
      description: {
        component: `Clear description of component purpose and usage`
      }
    }
  }
};
```

#### Container Component Template (Multiple Stories)
```typescript
const meta: Meta<typeof ContainerName> = {
  component: ContainerName,
  tags: ['container-name'],  // NO autodocs on meta
  decorators: [withReduxAndRouter],
  parameters: {
    layout: 'fullscreen',
    // ... other parameters
  }
};

// Only the default story gets autodocs
export const Default: Story = {
  tags: ['autodocs'],  // ONLY story with autodocs
  parameters: {
    docs: {
      description: {
        story: `
**Default View**: Complete container description with real API orchestration.

## Additional Test Stories

For testing specific scenarios, see these additional stories:

- **[LoadingState](?path=/story/path--loading-state)**: Tests container during API loading
- **[EmptyState](?path=/story/path--empty-state)**: Tests container with empty data
- **[ErrorState](?path=/story/path--error-state)**: Tests container error handling
        `,
      },
    },
    msw: {
      handlers: [
        // Real API mocking - NO storeState
        http.get('/api/endpoint/', () => HttpResponse.json({ data: mockData })),
      ],
    },
  },
  play: async ({ canvasElement }) => {
    // Test real API orchestration
  },
};

// Other stories have no docs config - just MSW and tests
export const LoadingState: Story = {
  parameters: {
    msw: {
      handlers: [
        http.get('/api/endpoint/', () => new Promise(() => {})), // Never resolves
      ],
    },
  },
  play: async ({ canvasElement }) => {
    // Test skeleton loading state (standard pattern)
    await waitFor(
      async () => {
        const skeletonElements = canvasElement.querySelectorAll('[class*="skeleton"]');
        await expect(skeletonElements.length).toBeGreaterThan(0);
      },
      { timeout: 10000 },
    );
  },
};
```

### Loading State Testing Requirements
- **REQUIRED**: All loading states must test for skeleton elements using the standard pattern
- **NEVER** test for absence of data - always test for presence of skeleton loading indicators
- Use `canvasElement.querySelectorAll('[class*="skeleton"]')` to find skeleton elements
- Always wrap in `waitFor` with appropriate timeout for async loading behavior

**Standard Loading State Test Pattern:**
```typescript
play: async ({ canvasElement }) => {
  // Test skeleton loading state (check for skeleton class)
  await waitFor(
    async () => {
      const skeletonElements = canvasElement.querySelectorAll('[class*="skeleton"]');
      await expect(skeletonElements.length).toBeGreaterThan(0);
    },
    { timeout: 10000 },
  );
},
```

### User Interaction Testing Requirements
- **REQUIRED**: All user interactions (clicks, form inputs, etc.) must have play functions
- Play functions should test the actual user flows, not just trigger events
- Cover all interactive states: hover, focus, disabled, error, etc.

### Testing Imports (REQUIRED)
- **ALWAYS** import testing utilities from `storybook/test` package (no @ symbol)
- **NEVER** import from individual packages like `@storybook/testing-library` or `@storybook/jest`
- **NEVER** use `@storybook/test` (with @ symbol) - this is incorrect
- Standard imports: `import { userEvent, within, expect, fn } from 'storybook/test';`
- `storybook/test` consolidates all testing utilities in modern Storybook versions

‚ö†Ô∏è **ALWAYS** `await` your `expect` calls inside a play function:
```typescript
await expect(canvas.findByText('Save')).resolves.toBeInTheDocument();
```
This is required so that results appear correctly in Storybook‚Äôs **Interactions** panel and so the test runner can report assertion failures reliably.

## Feature Flag Handling in Stories

### The Problem with Feature Flag Mocking
- **DON'T**: Rely on `parameters.unleash.flags` alone for testing feature flag logic
- Feature flag mocking in test runners often doesn't work reliably
- Container components need explicit feature flag simulation for proper testing

### The Solution: Custom Render Components
When components have feature flag logic, create a custom render component that simulates the exact logic:

```typescript
interface ComponentArgs {
  isFeatureEnabled: boolean;
  isUserEligible: boolean;
}

// Custom render component that simulates the container's feature flag logic
const ComponentWithFeatureFlags: React.FC<ComponentArgs> = ({ isFeatureEnabled, isUserEligible }) => {
  const shouldShowAlert = isUserEligible && !isFeatureEnabled;

  return (
    <React.Fragment>
      {shouldShowAlert && <FeatureAlert />}
      <MainComponent />
    </React.Fragment>
  );
};

const meta: Meta<ComponentArgs> = {
  component: MainComponent,
  argTypes: {
    isFeatureEnabled: {
      control: 'boolean',
      description: 'Whether feature is enabled (platform.feature.flag)',
      table: {
        type: { summary: 'boolean' },
        defaultValue: { summary: 'false' },
      },
    },
    isUserEligible: {
      control: 'boolean',
      description: 'Whether user is eligible for feature (platform.feature.eligible)',
      table: {
        type: { summary: 'boolean' },
        defaultValue: { summary: 'false' },
      },
    },
  },
  render: (args) => <ComponentWithFeatureFlags {...args} />,
};

export const WithFeatureEnabled: Story = {
  args: {
    isFeatureEnabled: true,
    isUserEligible: true,
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    // Test the feature flag logic directly
    expect(canvas.queryByText('Feature alert text')).not.toBeInTheDocument();
  },
};
```

### Feature Flag Best Practices
- **Document Logic**: Clearly explain the feature flag combinations in component docs
- **Use Controls**: Add `argTypes` for interactive boolean controls
- **Test All States**: Create stories for each meaningful flag combination
- **Explicit Logic**: Don't rely on unleash mocking - implement the logic explicitly
- **Realistic Text**: Use actual component text in assertions, not generic selectors

### Common Feature Flag Patterns
```typescript
// Pattern 1: Simple enable/disable
const shouldShow = isFeatureEnabled;

// Pattern 2: Eligibility + enable (common for opt-in features)  
const shouldShowAlert = isEligible && !isEnabled;

// Pattern 3: Multiple conditions
const shouldShowBeta = isBetaUser && isBetaEnabled && !isProduction;
```

## Storybook Actions & Event Handling

### Automatic Actions Configuration
- Actions are **automatically configured** for all `on*` props
- Props starting with `on` (onClick, onChange, etc.) automatically log to Actions panel
- **Don't use `console.log`** in story event handlers
- **Don't use manual `action()` calls for `on*` props**

### Play Functions for Testing
```typescript
import { userEvent, within, expect, fn } from 'storybook/test';

export const ClickableStory: Story = {
  args: {
    onClick: fn(),  // Testable spy function
  },
  play: async ({ canvasElement, args }) => {
    const canvas = within(canvasElement);
    await userEvent.click(canvas.getByText('5', { selector: 'a' }));
    await expect(args.onClick).toHaveBeenCalled();
  }
};
```

### Play Function Guidelines
- **Use `fn()` for individual stories** - creates testable spy functions
- **Use specific selectors** - `{ selector: 'a' }` to target exact elements
- **Test both positive and negative cases**
- **Never add play functions to comparison stories**

#### Debounced API Calls
When testing spies for debounced operations (filtering, search), use `waitFor()`:

```typescript
// ‚úÖ CORRECT: Debounced filtering with waitFor
export const FilterStory: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    const filterInput = await canvas.findByPlaceholderText(/filter by name/i);
    await userEvent.type(filterInput, 'Platform');
    
    // Use waitFor for debounced spy assertions
    await waitFor(() => {
      expect(filterSpy).toHaveBeenCalledWith('Platform');
    });
    
    await userEvent.clear(filterInput);
    await userEvent.type(filterInput, 'Management');
    
    await waitFor(() => {
      expect(filterSpy).toHaveBeenCalledWith('Management');
    });
  },
};

// ‚ùå WRONG: Immediate assertion may fail due to debouncing
await userEvent.type(filterInput, 'Platform');
expect(filterSpy).toHaveBeenCalledWith('Platform'); // May fail if debounced
```

#### Non-Debounced Operations
For immediate operations (clicks, selections), direct spy assertions work:

```typescript
// ‚úÖ CORRECT: Immediate operations don't need waitFor
await userEvent.click(button);
expect(clickSpy).toHaveBeenCalled(); // Immediate assertion OK

await userEvent.click(sortHeader);
expect(sortSpy).toHaveBeenCalledWith('display_name'); // Immediate assertion OK
```

=======
## API Call Testing with MSW Spies (CRITICAL PATTERN)

### The Problem: Testing API Integration
- Components make API calls via Redux actions or direct fetch
- Need to verify correct API calls are made with proper parameters
- MSW handlers mock responses but don't track calls by default

### The Solution: API Spy Pattern
**ALWAYS** use this 3-step pattern to test API calls in container stories:

#### Step 1: Create API Spies
```typescript
// At the top of your story file (outside meta/stories)
const groupsApiSpy = fn();
const createGroupSpy = fn();
const updateGroupSpy = fn();
const deleteGroupSpy = fn();
```

#### Step 2: Call Spies in MSW Handlers
```typescript
const meta: Meta<typeof Component> = {
  parameters: {
    msw: {
      handlers: [
        // GET endpoint - spy tracks parameters
        http.get('/api/rbac/v1/groups/', ({ request }) => {
          const url = new URL(request.url);
          const name = url.searchParams.get('name') || '';
          const limit = parseInt(url.searchParams.get('limit') || '20');
          const offset = parseInt(url.searchParams.get('offset') || '0');
          
          // CRITICAL: Call spy with parameters for testing
          groupsApiSpy({
            name,
            limit: limit.toString(),
            offset: offset.toString(),
            order_by: url.searchParams.get('order_by') || 'name',
          });
          
          return HttpResponse.json({ data: mockData, meta: { count: 1, limit, offset } });
        }),
        
        // POST endpoint - spy tracks request body
        http.post('/api/rbac/v1/groups/', async ({ request }) => {
          const body = await request.json();
          
          // CRITICAL: Call spy with body for testing
          createGroupSpy({
            name: body.name,
            description: body.description,
          });
          
          return HttpResponse.json({ uuid: 'new-group-id', ...body });
        }),
        
        // PUT endpoint - spy tracks both params and body
        http.put('/api/rbac/v1/groups/:groupId/', async ({ params, request }) => {
          const body = await request.json();
          
          // CRITICAL: Call spy with both params and body
          updateGroupSpy({
            groupId: params.groupId,
            updates: body,
          });
          
          return HttpResponse.json({ uuid: params.groupId, ...body });
        }),
        
        // DELETE endpoint - spy tracks params
        http.delete('/api/rbac/v1/groups/:groupId/', ({ params }) => {
          // CRITICAL: Call spy with deletion info
          deleteGroupSpy({ groupId: params.groupId });
          
          return HttpResponse.json({}, { status: 204 });
        }),
      ],
    },
  },
};
```

#### Step 3: Test Spies in Play Functions
```typescript
export const TestAPIIntegration: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Wait for initial API calls
    await delay(300);
    
    // CRITICAL: Verify initial load API call
    expect(groupsApiSpy).toHaveBeenCalledWith({
      name: '',
      limit: '20', 
      offset: '0',
      order_by: 'name',
    });
    
    // Test user interaction that triggers API call
    const createButton = await canvas.findByRole('button', { name: /create/i });
    await userEvent.click(createButton);
    
    // Fill and submit form
    const nameInput = await canvas.findByLabelText(/group name/i);
    await userEvent.type(nameInput, 'New Test Group');
    
    const submitButton = await canvas.findByRole('button', { name: /save/i });
    await userEvent.click(submitButton);
    
    // CRITICAL: Verify create API call was made with correct data
    await waitFor(async () => {
      expect(createGroupSpy).toHaveBeenCalledWith({
        name: 'New Test Group',
        description: '', // or expected value
      });
    });
    
    // CRITICAL: Verify refresh API call after creation
    expect(groupsApiSpy).toHaveBeenCalledTimes(2); // Initial + refresh
  },
};
```

### API Spy Pattern Best Practices

#### Required Spy Naming Convention
- Use descriptive names ending with `Spy`: `groupsApiSpy`, `createGroupSpy`
- Match the API endpoint purpose: `getUsersSpy`, `deleteUserSpy`
- Group related spies together in the same story file

#### MSW Handler Requirements
- **ALWAYS** call the spy inside the handler function
- **ALWAYS** extract and pass meaningful parameters to spy
- **ALWAYS** return appropriate mock data after spy call
- Use `request.json()` for POST/PUT bodies, `params` for path params, `url.searchParams` for query params

#### Play Function Requirements
- **ALWAYS** test that spies were called: `expect(apiSpy).toHaveBeenCalled()`
- **ALWAYS** verify spy parameters: `expect(apiSpy).toHaveBeenCalledWith({ expected: 'params' })`
- **ALWAYS** use `toHaveBeenCalledTimes(n)` when testing multiple calls
- **ALWAYS** wrap spy assertions in `waitFor` for async operations

### Common API Spy Patterns

#### Pattern 1: Query Parameter Testing
```typescript
// MSW Handler
groupsApiSpy({
  name: url.searchParams.get('name') || '',
  limit: url.searchParams.get('limit') || '20',
  admin_default: url.searchParams.get('admin_default'),
});

// Play Function Test  
expect(groupsApiSpy).toHaveBeenCalledWith({
  name: 'test-filter',
  limit: '10',
  admin_default: 'true',
});
```

#### Pattern 2: Request Body Testing
```typescript
// MSW Handler
const body = await request.json();
createUserSpy({
  username: body.username,
  email: body.email,
  roles: body.roles || [],
});

// Play Function Test
expect(createUserSpy).toHaveBeenCalledWith({
  username: 'john.doe',
  email: 'john@example.com', 
  roles: ['user', 'admin'],
});
```

#### Pattern 3: Multiple Call Verification
```typescript
// Play Function Test
expect(groupsApiSpy).toHaveBeenCalledTimes(2);
expect(groupsApiSpy).toHaveBeenNthCalledWith(1, { name: '', limit: '20' });
expect(groupsApiSpy).toHaveBeenNthCalledWith(2, { name: 'filtered', limit: '20' });
```

### Integration with Global Spies

Some spies are defined globally in `.storybook/context-providers.tsx`:
```typescript
import { chromeAppNavClickSpy } from '../../../.storybook/context-providers';

// Test Chrome integration
expect(chromeAppNavClickSpy).toHaveBeenCalledWith({ 
  id: 'groups', 
  secondaryNav: true 
});
```

### Why This Pattern Works
- **Real API Testing**: Tests actual API integration, not pre-populated state
- **Parameter Validation**: Ensures correct data is sent to APIs
- **Integration Verification**: Tests the complete Redux action ‚Üí API ‚Üí response flow
- **Regression Prevention**: Catches API contract changes and parameter bugs
- **Documentation**: Serves as living documentation of API usage patterns

## React-Data-View Usage & Testing Patterns (CRITICAL)

### The Problem: Common AI React-Data-View Mistakes
The AI frequently gets these react-data-view patterns wrong:

1. **Bulk Select**: Doesn't work or works only partially
2. **Toolbar Action Dropdown**: Often missing or not working properly
3. **Table Row Actions**: Missing action dropdowns
4. **Search/Pagination/Sorting**: Wrong implementation and missing tests

### Required Imports & Dependencies
```typescript
// Core DataView components - ALWAYS use these exact imports
import { DataView, DataViewState } from '@patternfly/react-data-view';
import { DataViewToolbar } from '@patternfly/react-data-view/dist/dynamic/DataViewToolbar';
import { DataViewTable } from '@patternfly/react-data-view/dist/dynamic/DataViewTable';
import { DataViewTextFilter } from '@patternfly/react-data-view';
import DataViewFilters from '@patternfly/react-data-view/dist/cjs/DataViewFilters';

// Hooks - ALWAYS use these exact imports
import { useDataViewFilters, useDataViewSelection, useDataViewPagination } from '@patternfly/react-data-view';

// BulkSelect - CRITICAL: From react-component-groups, NOT react-core
import { BulkSelect, BulkSelectValue } from '@patternfly/react-component-groups/dist/dynamic/BulkSelect';

// Skeleton components
import { SkeletonTableBody, SkeletonTableHead } from '@patternfly/react-component-groups';
```

### 1. BULK SELECT PATTERN (CRITICAL)

#### Hook Setup - REQUIRED Pattern
```typescript
// CRITICAL: Use exact hook pattern
const selection = useDataViewSelection({
  matchOption: (a, b) => a.id === b.id, // REQUIRED for proper selection matching
});

// CRITICAL: BulkSelect handler with all required cases
const handleBulkSelect = useCallback(
  (value: BulkSelectValue) => {
    if (value === BulkSelectValue.none) {
      selection.onSelect(false); // Clear all selections
    } else if (value === BulkSelectValue.page) {
      selection.onSelect(true, tableRows); // CRITICAL: Pass tableRows, not raw data
    } else if (value === BulkSelectValue.nonePage) {
      selection.onSelect(false, tableRows);
    }
    // Note: 'all' across pages handled differently if needed
  },
  [selection, tableRows] // CRITICAL: Include tableRows in dependencies
);
```

#### Component Structure - REQUIRED Pattern
```typescript
// CRITICAL: Memoized BulkSelect component to prevent infinite loops
const bulkSelectComponent = useMemo(() => {
  if (!hasPermissions || isAdminDefault) {
    return undefined; // No bulk select for restricted users
  }

  const selectedCount = selection.selected?.length || 0;
  const totalCount = items.length;

  return (
    <BulkSelect
      isDataPaginated={false} // Set true if using pagination
      selectedCount={selectedCount}
      totalCount={totalCount}
      pageCount={totalCount} // For current page count
      onSelect={handleBulkSelect}
    />
  );
}, [hasPermissions, isAdminDefault, selection.selected?.length, items.length, handleBulkSelect]);

// DataView component - CRITICAL selection prop
<DataView
  activeState={activeState}
  selection={hasPermissions ? selection : undefined} // CRITICAL: Conditional selection
>
  <DataViewToolbar
    bulkSelect={bulkSelectComponent} // CRITICAL: Pass memoized component
    // ... other toolbar props
  />
</DataView>
```

#### BulkSelect Testing Pattern - MANDATORY
```typescript
export const BulkSelection: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Wait for table and data
    await canvas.findByRole('grid');
    expect(await canvas.findByText('alice.johnson')).toBeInTheDocument();
    
    // CRITICAL: Find bulk select checkbox (first checkbox)
    const checkboxes = await canvas.findAllByRole('checkbox');
    const bulkSelectCheckbox = checkboxes[0]; // First is bulk select
    expect(bulkSelectCheckbox).not.toBeChecked();
    
    // CRITICAL: Test bulk selection
    await userEvent.click(bulkSelectCheckbox);
    expect(bulkSelectCheckbox).toBeChecked();
    
    // CRITICAL: Verify individual rows are selected
    const rowCheckboxes = checkboxes.filter((cb) => cb !== bulkSelectCheckbox);
    rowCheckboxes.forEach((checkbox) => {
      expect(checkbox).toBeChecked();
    });
    
    // CRITICAL: Test deselection
    await userEvent.click(bulkSelectCheckbox);
    expect(bulkSelectCheckbox).not.toBeChecked();
    rowCheckboxes.forEach((checkbox) => {
      expect(checkbox).not.toBeChecked();
    });
  },
};
```

### 2. TOOLBAR ACTION DROPDOWN PATTERN

#### Component Structure - REQUIRED Pattern
```typescript
// CRITICAL: Conditional toolbar actions based on selection
const toolbarActions = useMemo(() => {
  if (!hasPermissions) return undefined;
  
  return (
    <>
      {/* Primary actions - ALWAYS outside kebab menu */}
      <Button variant="primary" onClick={handleAddItem}>
        Add Item
      </Button>
      
      {/* Secondary actions - CONDITIONAL based on selection */}
      {selection.selected.length > 0 && (
        <Button
          variant="secondary"
          onClick={() => handleBulkAction(selection.selected)}
        >
          Remove ({selection.selected.length})
        </Button>
      )}
      
      {/* Kebab menu for additional actions */}
      <KebabActionsMenu
        selectedItems={selection.selected}
        onRemove={handleRemove}
        // ... other actions
      />
    </>
  );
}, [hasPermissions, selection.selected, handleAddItem, handleBulkAction]);

<DataViewToolbar
  bulkSelect={bulkSelectComponent}
  actions={toolbarActions} // CRITICAL: Conditional actions
  // ... other props
/>
```

#### Toolbar Actions Testing - MANDATORY
```typescript
export const ToolbarActionsState: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // CRITICAL: Test primary button (always visible)
    const addButton = await canvas.findByRole('button', { name: 'Add Item' });
    expect(addButton).not.toHaveAttribute('disabled');
    
    // CRITICAL: Test kebab menu (initial state - no selection)
    const kebabButtons = await canvas.findAllByLabelText('Kebab toggle');
    const toolbarKebab = kebabButtons[0]; // First is toolbar kebab
    await userEvent.click(toolbarKebab);
    
    // CRITICAL: Verify disabled state when no selection
    const removeOption = await canvas.findByRole('menuitem', { name: 'Remove' });
    expect(removeOption).toHaveAttribute('disabled');
    
    // Close menu and select item
    await userEvent.click(canvasElement);
    
    // CRITICAL: Select a row to test enabled state
    const firstRow = (await canvas.findByText('alice.johnson')).closest('tr');
    const rowCheckbox = within(firstRow).getByRole('checkbox');
    await userEvent.click(rowCheckbox);
    
    // CRITICAL: Test enabled state after selection
    await userEvent.click(toolbarKebab);
    const removeAfter = await canvas.findByRole('menuitem', { name: 'Remove' });
    expect(removeAfter).not.toHaveAttribute('disabled');
  },
};
```

### 3. TABLE ROW ACTION DROPDOWN PATTERN

#### Row Actions Component - REQUIRED Pattern
```typescript
// CRITICAL: Individual row actions component
const RowActionsMenu: React.FC<{ item: ItemType; onRemove: (item: ItemType) => void }> = ({ item, onRemove }) => {
  const [isOpen, setIsOpen] = useState(false);
  
  return (
    <Dropdown
      isOpen={isOpen}
      onSelect={() => setIsOpen(false)}
      toggle={
        <MenuToggle
          aria-label="Kebab toggle"
          variant="plain"
          onClick={() => setIsOpen(!isOpen)}
        >
          <EllipsisVIcon />
        </MenuToggle>
      }
    >
      <DropdownList>
        <DropdownItem onClick={() => onRemove(item)}>
          Remove
        </DropdownItem>
        {/* Additional actions */}
      </DropdownList>
    </Dropdown>
  );
};

// CRITICAL: Table rows with actions column
const tableRows = useMemo(() => {
  return items.map((item) => ({
    id: item.id, // CRITICAL: Must have id for selection
    cells: [
      item.name,
      item.status,
      // CRITICAL: Actions cell as last column
      hasPermissions ? (
        <RowActionsMenu item={item} onRemove={handleRemove} />
      ) : null,
    ],
  }));
}, [items, hasPermissions, handleRemove]);
```

#### Row Actions Testing - MANDATORY
```typescript
export const RowActions: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Wait for table data
    expect(await canvas.findByText('alice.johnson')).toBeInTheDocument();
    
    // CRITICAL: Find row and its action button
    const aliceRow = (await canvas.findByText('alice.johnson')).closest('tr');
    const rowKebab = within(aliceRow).getByLabelText('Kebab toggle');
    expect(rowKebab).toBeInTheDocument();
    
    // CRITICAL: Test row action menu
    await userEvent.click(rowKebab);
    
    // CRITICAL: Verify row actions are available and enabled
    const removeAction = await canvas.findByRole('menuitem', { name: 'Remove' });
    expect(removeAction).not.toHaveAttribute('disabled');
    
    // CRITICAL: Verify menu positioning
    const menu = removeAction.closest('[role="menu"]');
    expect(menu).toBeInTheDocument();
  },
};
```

### 4. FILTERING & SEARCH PATTERN

#### Filter Hook Setup - REQUIRED Pattern
```typescript
// CRITICAL: Filter types interface
interface DataViewFilters {
  name: string;
  status?: string;
}

// CRITICAL: useDataViewFilters hook
const filters = useDataViewFilters<DataViewFilters>({
  initialFilters: {
    name: '', // REQUIRED: Initialize all filters
    status: '',
  },
});

// CRITICAL: Debounced filter handler
const debouncedFetchData = useMemo(() => debounce(fetchData, 500), [fetchData]);

const handleFilterChange = useCallback(
  (_event: any, newFilters: DataViewFilters) => {
    filters.onSetFilters(newFilters); // Update filter state
    debouncedFetchData(newFilters.name, { offset: 0 }); // Reset to page 1
  },
  [filters, debouncedFetchData]
);

// CRITICAL: Clear filters handler
const handleClearAllFilters = useCallback(() => {
  filters.onSetFilters({ name: '', status: '' });
  fetchData(undefined, { offset: 0 });
}, [filters, fetchData]);

// CRITICAL: Active filters detection
const hasActiveFilters = useMemo(() => {
  return Object.values(filters.filters).some(value => value && value.trim() !== '');
}, [filters.filters]);
```

#### Filter Component Structure - REQUIRED Pattern
```typescript
<DataViewToolbar
  filters={
    <DataViewFilters onChange={handleFilterChange} values={filters.filters}>
      <DataViewTextFilter
        filterId="name" // CRITICAL: Must match filter interface
        title="Name"
        placeholder="Filter by name"
      />
      <DataViewTextFilter
        filterId="status"
        title="Status" 
        placeholder="Filter by status"
      />
    </DataViewFilters>
  }
  clearAllFilters={hasActiveFilters ? handleClearAllFilters : undefined} // CRITICAL: Conditional
  // ... other props
/>
```

#### Filter Testing Pattern - MANDATORY
```typescript
export const FilterMembers: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Wait for initial data
    expect(await canvas.findByText('alice.johnson')).toBeInTheDocument();
    expect(await canvas.findByText('bob.smith')).toBeInTheDocument();
    
    // CRITICAL: Test filter input
    const filterInput = await canvas.findByPlaceholderText('Filter by name');
    await userEvent.type(filterInput, 'alice');
    
    // CRITICAL: Wait for debounced filter to complete
    await delay(600); // Wait longer than debounce delay
    
    // CRITICAL: Verify filtered results
    expect(await canvas.findByText('alice.johnson')).toBeInTheDocument();
    expect(canvas.queryByText('bob.smith')).not.toBeInTheDocument();
    
    // CRITICAL: Test clear filters button
    const clearFiltersButton = await canvas.findByRole('button', { name: /clear.*filter/i });
    await userEvent.click(clearFiltersButton);
    
    // CRITICAL: Verify all data returns
    expect(await canvas.findByText('alice.johnson')).toBeInTheDocument();
    expect(await canvas.findByText('bob.smith')).toBeInTheDocument();
  },
};
```

### 5. PAGINATION PATTERN

#### Pagination Hook - REQUIRED Pattern
```typescript
// CRITICAL: Pagination hook setup
const pagination = useDataViewPagination({
  perPage: 20, // Default page size
});

// CRITICAL: Fetch with pagination parameters
const fetchData = useCallback((filters = {}, apiProps = {}) => {
  const options = {
    ...defaultSettings,
    limit: pagination.perPage, // CRITICAL: Use hook's perPage
    offset: (pagination.page - 1) * pagination.perPage, // CRITICAL: Calculate offset
    ...apiProps,
  };
  
  dispatch(fetchItems(groupId, filters, options));
}, [dispatch, groupId, pagination.perPage, pagination.page]);
```

### 6. LOADING & EMPTY STATES PATTERN (CRITICAL)

#### State Management - REQUIRED Pattern
```typescript
// CRITICAL: DataView state calculation
const activeState = useMemo(() => {
  if (isLoading) return DataViewState.loading;
  if (items.length === 0) return DataViewState.empty;
  return undefined; // Show normal table
}, [isLoading, items.length]);

// CRITICAL: Skeleton components
const loadingHeader = useMemo(
  () => <SkeletonTableHead columns={columns.map(col => col.cell)} />,
  [columns]
);

const loadingBody = useMemo(
  () => <SkeletonTableBody rowsCount={10} columnsCount={columns.length} />,
  [columns.length]
);

// CRITICAL: Empty state component with conditional logic
const emptyState = useMemo(
  () => <ItemsEmptyState colSpan={columns.length} hasActiveFilters={hasActiveFilters} />,
  [columns.length, hasActiveFilters]
);

// CRITICAL: DataView with states
<DataView activeState={activeState} selection={selection}>
  <DataViewTable
    columns={columns}
    rows={tableRows}
    headStates={{ loading: loadingHeader }} // CRITICAL: Loading states
    bodyStates={{
      loading: loadingBody,
      empty: emptyState, // CRITICAL: Conditional empty state
    }}
  />
</DataView>
```

#### Empty State Component Pattern - REQUIRED Structure
```typescript
import { EmptyState, EmptyStateBody, EmptyStateHeader, EmptyStateIcon, EmptyStateActions, EmptyStateFooter } from '@patternfly/react-core/dist/dynamic/components/EmptyState';
import { Button } from '@patternfly/react-core/dist/dynamic/components/Button';
import { Tbody, Td, Tr } from '@patternfly/react-table/dist/dynamic/components/Table';
import { SearchIcon } from '@patternfly/react-icons/dist/dynamic/icons/search-icon';
import { UsersIcon } from '@patternfly/react-icons/dist/dynamic/icons/users-icon'; // Domain-appropriate icon

interface ItemsEmptyStateProps {
  colSpan: number; // CRITICAL: Must match table column count
  hasActiveFilters: boolean; // CRITICAL: Determines which empty state to show
  title?: string; // Optional custom title for no-data state
  description?: string; // Optional custom description
}

export const ItemsEmptyState: React.FC<ItemsEmptyStateProps> = ({ 
  colSpan, 
  hasActiveFilters,
  title = "Configure items",
  description = "Create at least one item to get started."
}) => {
  const intl = useIntl();

  return (
    <Tbody>
      <Tr>
        <Td colSpan={colSpan}> {/* CRITICAL: Proper table structure */}
          {hasActiveFilters ? (
            // NO RESULTS STATE: When filtering returns empty results
            <EmptyState>
              <EmptyStateHeader
                titleText="No items match your search"
                headingLevel="h4"
                icon={<EmptyStateIcon icon={SearchIcon} />} {/* CRITICAL: SearchIcon for filter results */}
              />
              <EmptyStateBody>
                Try adjusting your search filters to find the items you're looking for.
              </EmptyStateBody>
            </EmptyState>
          ) : (
            // NO DATA STATE: When there's genuinely no data
            <EmptyState>
              <EmptyStateHeader
                titleText={title}
                headingLevel="h4"
                icon={<EmptyStateIcon icon={UsersIcon} />} {/* CRITICAL: Domain icon for no-data */}
              />
              <EmptyStateBody>{description}</EmptyStateBody>
              {hasPermissions && (
                <EmptyStateFooter>
                  <EmptyStateActions>
                    <Button variant="primary" onClick={handleCreateItem}>
                      Create Item
                    </Button>
                  </EmptyStateActions>
                </EmptyStateFooter>
              )}
            </EmptyState>
          )}
        </Td>
      </Tr>
    </Tbody>
  );
};
```

#### Empty State Props Calculation - REQUIRED Pattern
```typescript
// CRITICAL: Calculate empty state props based on filters and permissions
const emptyStateProps = useMemo(() => {
  return {
    colSpan: columns.length, // CRITICAL: Match actual column count
    hasActiveFilters, // CRITICAL: Determines empty state type
    title: hasPermissions 
      ? `Configure ${intl.formatMessage(messages.items).toLowerCase()}`
      : `No ${intl.formatMessage(messages.items).toLowerCase()} available`,
    description: hasPermissions
      ? intl.formatMessage(messages.createAtLeastOneItem, { 
          item: intl.formatMessage(messages.item).toLowerCase() 
        })
      : intl.formatMessage(messages.noAccessToViewItems),
  };
}, [columns.length, hasActiveFilters, hasPermissions, intl]);

// CRITICAL: Pass props to empty state component
const emptyState = useMemo(
  () => <ItemsEmptyState {...emptyStateProps} />,
  [emptyStateProps]
);
```

#### Domain-Specific Icons - REQUIRED Mapping
```typescript
// CRITICAL: Use appropriate icons for different domains
import { UsersIcon } from '@patternfly/react-icons/dist/dynamic/icons/users-icon'; // Groups/Members
import { CubesIcon } from '@patternfly/react-icons/dist/dynamic/icons/cubes-icon'; // Roles
import { ServiceCatalogIcon } from '@patternfly/react-icons/dist/dynamic/icons/service-catalog-icon'; // Service Accounts
import { SearchIcon } from '@patternfly/react-icons/dist/dynamic/icons/search-icon'; // ALWAYS for filter results

// Domain mapping:
// - Groups/Members: UsersIcon
// - Roles/Permissions: CubesIcon  
// - Service Accounts: ServiceCatalogIcon
// - Filter Results: ALWAYS SearchIcon
```

#### Empty State Testing Pattern - MANDATORY
```typescript
export const EmptyState: Story = {
  parameters: {
    msw: {
      handlers: [
        // CRITICAL: Return empty data to trigger empty state
        http.get('/api/endpoint/', () => {
          return HttpResponse.json({
            data: [], // CRITICAL: Empty array
            meta: { count: 0, limit: 20, offset: 0 },
          });
        }),
      ],
    },
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // CRITICAL: Wait for table to load
    expect(await canvas.findByRole('grid')).toBeInTheDocument();
    
    // CRITICAL: Test NO DATA empty state (no active filters)
    expect(await canvas.findByText(/configure.*items/i)).toBeInTheDocument();
    
    // CRITICAL: Verify domain-appropriate icon (not SearchIcon for no-data)
    // Look for empty state container and verify it doesn't have search icon
    const emptyStateContainer = (await canvas.findByText(/configure.*items/i)).closest('[class*="pf-v5-c-empty-state"]');
    expect(emptyStateContainer).toBeInTheDocument();
    
    // CRITICAL: Test create button for admin users (if applicable)
    if (hasPermissions) {
      expect(await canvas.findByRole('button', { name: /create/i })).toBeInTheDocument();
    }
  },
};

export const NoResultsAfterFilter: Story = {
  parameters: {
    msw: {
      handlers: [
        // CRITICAL: Return empty results for filtered queries
        http.get('/api/endpoint/', ({ request }) => {
          const url = new URL(request.url);
          const hasFilter = url.searchParams.get('name') && url.searchParams.get('name') !== '';
          
          if (hasFilter) {
            return HttpResponse.json({
              data: [], // CRITICAL: Empty results for filter
              meta: { count: 0, limit: 20, offset: 0 },
            });
          }
          
          return HttpResponse.json({
            data: mockData, // Return data if no filter
            meta: { count: mockData.length, limit: 20, offset: 0 },
          });
        }),
      ],
    },
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Wait for initial data load
    expect(await canvas.findByRole('grid')).toBeInTheDocument();
    expect(await canvas.findByText('alice.johnson')).toBeInTheDocument();
    
    // CRITICAL: Apply filter that returns no results
    const filterInput = await canvas.findByPlaceholderText('Filter by name');
    await userEvent.type(filterInput, 'nonexistent');
    
    // CRITICAL: Wait for debounced filter
    await delay(600);
    
    // CRITICAL: Test NO RESULTS empty state (has active filters)
    expect(await canvas.findByText(/no.*items.*match.*search/i)).toBeInTheDocument();
    
    // CRITICAL: Verify SearchIcon is used for filter results
    const searchEmptyState = (await canvas.findByText(/no.*items.*match.*search/i)).closest('[class*="pf-v5-c-empty-state"]');
    expect(searchEmptyState?.querySelector('svg')).toBeInTheDocument(); // Should have search icon
    
    // CRITICAL: Verify filter suggestion text
    expect(await canvas.findByText(/try adjusting.*search filters/i)).toBeInTheDocument();
  },
};
```

#### Empty State vs Loading State Distinction
```typescript
// CRITICAL: Clear distinction between loading and empty
export const Loading: Story = {
  parameters: {
    msw: {
      handlers: [
        http.get('/api/endpoint/', () => new Promise(() => {})), // Never resolves
      ],
    },
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // CRITICAL: Should show skeleton, NOT empty state
    await waitFor(async () => {
      const skeletonElements = canvasElement.querySelectorAll('[class*="skeleton"]');
      await expect(skeletonElements.length).toBeGreaterThan(0);
    });
    
    // CRITICAL: Should NOT show empty state content
    expect(canvas.queryByText(/configure.*items/i)).not.toBeInTheDocument();
    expect(canvas.queryByText(/no.*items.*match/i)).not.toBeInTheDocument();
  },
};
```

### Empty State Anti-Patterns to Avoid

#### ‚ùå Common Mistakes
```typescript
// ‚ùå WRONG: Using SearchIcon for no-data state
<EmptyStateIcon icon={SearchIcon} /> // Should use domain icon (UsersIcon, CubesIcon, etc.)

// ‚ùå WRONG: Same message for both empty states
const title = "No items found"; // Should differentiate between no-data vs no-results

// ‚ùå WRONG: Missing table structure
return <EmptyState>...</EmptyState>; // Should wrap in <Tbody><Tr><Td colSpan={colSpan}>

// ‚ùå WRONG: Incorrect colSpan
<Td colSpan={5}> // Should match actual column count dynamically

// ‚ùå WRONG: Not handling hasActiveFilters
const emptyState = <GenericEmptyState />; // Should pass hasActiveFilters

// ‚ùå WRONG: Testing empty state with loading query
expect(canvas.getByText('Configure items')).toBeInTheDocument(); // Should use findByText

// ‚ùå WRONG: Not distinguishing between loading and empty in tests
// Both states show "no content" but are fundamentally different
```

### 7. CRITICAL TESTING REQUIREMENTS

#### Story Structure Requirements
```typescript
// CRITICAL: Container story pattern for DataView components
const meta: Meta<typeof DataViewComponent> = {
  component: DataViewComponent,
  tags: ['dataview-container'], // NO autodocs on meta
  parameters: {
    msw: {
      handlers: [
        // CRITICAL: API spy pattern for testing
        http.get('/api/endpoint/', ({ request }) => {
          apiSpy({ /* track parameters */ });
          return HttpResponse.json({ data: mockData });
        }),
      ],
    },
  },
};

export const Default: Story = {
  tags: ['autodocs'], // ONLY story with autodocs
  parameters: {
    docs: {
      description: {
        story: `
**DataView Container** with comprehensive react-data-view functionality.

## Features Tested
- ‚úÖ **Bulk Selection** - Select all/none/page functionality
- ‚úÖ **Toolbar Actions** - Conditional actions based on selection
- ‚úÖ **Row Actions** - Individual item action menus  
- ‚úÖ **Filtering** - Real-time search with debouncing
- ‚úÖ **Pagination** - Page size and navigation
- ‚úÖ **Loading States** - Skeleton loading indicators
- ‚úÖ **Empty States** - Both no-data and no-results scenarios

## Additional Test Stories
- **[BulkSelection](?path=/story/path--bulk-selection)**: Bulk select functionality
- **[ToolbarActions](?path=/story/path--toolbar-actions)**: Toolbar state management
- **[RowActions](?path=/story/path--row-actions)**: Individual row actions
- **[FilterItems](?path=/story/path--filter-items)**: Search and filtering
- **[EmptyState](?path=/story/path--empty-state)**: No-data scenario with domain icon
- **[NoResultsAfterFilter](?path=/story/path--no-results-after-filter)**: Filter results with SearchIcon
- **[Loading](?path=/story/path--loading)**: Skeleton loading state
        `,
      },
    },
  },
  play: async ({ canvasElement }) => {
    // CRITICAL: Comprehensive testing of all DataView features
    const canvas = within(canvasElement);
    
    // Test initial load
    expect(await canvas.findByRole('grid')).toBeInTheDocument();
    expect(await canvas.findByText('alice.johnson')).toBeInTheDocument();
    
    // Test toolbar elements
    expect(await canvas.findByRole('button', { name: 'Add Item' })).toBeInTheDocument();
    
    // Test bulk select
    const checkboxes = await canvas.findAllByRole('checkbox');
    expect(checkboxes.length).toBeGreaterThan(1);
    
    // Test row actions
    const kebabButtons = await canvas.findAllByLabelText('Kebab toggle');
    expect(kebabButtons.length).toBeGreaterThan(1); // Toolbar + row kebabs
  },
};
```

### 8. ANTI-PATTERNS TO AVOID

#### ‚ùå Common Mistakes
```typescript
// ‚ùå WRONG: Missing matchOption in selection hook
const selection = useDataViewSelection(); // Missing matchOption

// ‚ùå WRONG: Passing raw data to bulk selection
selection.onSelect(true, rawData); // Should pass tableRows

// ‚ùå WRONG: BulkSelect from wrong package
import { BulkSelect } from '@patternfly/react-core'; // Wrong package

// ‚ùå WRONG: Non-conditional selection in DataView
<DataView selection={selection}> // Should be conditional based on permissions

// ‚ùå WRONG: Missing row actions for admin users
const tableRows = items.map(item => ({
  id: item.id,
  cells: [item.name, item.status] // Missing actions column
}));

// ‚ùå WRONG: Synchronous queries in DataView testing
expect(canvas.getByRole('grid')).toBeInTheDocument(); // Should use findByRole

// ‚ùå WRONG: Not testing bulk select checkbox state
// Must test checked/unchecked states for both bulk and individual checkboxes
```

### React-Data-View Checklist for Stories

#### Required Testing Coverage
- [ ] ‚úÖ **Bulk Selection**: Test select all, select none, individual selection
- [ ] ‚úÖ **Toolbar Actions**: Test conditional enable/disable based on selection
- [ ] ‚úÖ **Row Actions**: Test individual item action menus
- [ ] ‚úÖ **Filtering**: Test debounced search with real API calls  
- [ ] ‚úÖ **Pagination**: Test page navigation and size changes
- [ ] ‚úÖ **Loading States**: Test skeleton loading indicators
- [ ] ‚úÖ **Empty States**: Test BOTH no-data and no-results scenarios with correct icons
- [ ] ‚úÖ **Permissions**: Test admin vs non-admin functionality
- [ ] ‚úÖ **API Integration**: Test with API spies, not pre-populated state

### Critical Empty State Testing Requirements
Every DataView component MUST have these specific stories:

- **EmptyState**: Tests no-data scenario with domain icon and create button
- **NoResultsAfterFilter**: Tests filter results with SearchIcon and filter guidance
- **Loading**: Tests skeleton indicators, NOT empty states

This comprehensive react-data-view documentation prevents the common AI mistakes and ensures proper implementation and testing of all interactive features.

### Args Parameter Management
**CRITICAL**: Only remove `args` parameter if the story doesn't use it.

#### When Args is Required
```typescript
// ‚úÖ Story NEEDS args - testing callbacks
play: async ({ canvasElement, args }) => {
  // Story tests callback functions
  expect(args.onClick).toHaveBeenCalled();
}

// ‚ùå WRONG - removing args breaks the test
play: async ({ canvasElement }) => {
  expect(args.onClick).toHaveBeenCalled(); // ReferenceError: args is not defined
}
```

#### When Args Can Be Removed
```typescript
// ‚úÖ Story doesn't use args - can remove safely
play: async ({ canvasElement }) => {
  const canvas = within(canvasElement);
  expect(canvas.getByText('Content')).toBeInTheDocument();
  // No callback testing, no args needed
}
```

#### Checking Story Dependencies
Before removing `args` parameter, check the play function for:
- `args.onSomething` usage (callback testing)
- `expect(args.property)` assertions
- Any reference to story arguments

## Quality Requirements for Stories

### Before Submitting Stories
- [ ] **Check dependency versions** in `package.json` for correct API usage
- [ ] Stories document target component, not wrappers
- [ ] No custom `title` in meta (using autotitle)
- [ ] All TypeScript errors resolved
- [ ] `npm run build` passes
- [ ] `npm run lint:js` passes (no errors, warnings OK)
- [ ] `npm run test-storybook:ci` passes (REQUIRED after adding any story)
- [ ] Realistic data structures used
- [ ] PatternFly components properly integrated
- [ ] JSX elements in arrays have `key` props

### Story Testing
- **REQUIRED**: Run `npm run test-storybook:ci` after adding any new story
- This command tests all play functions and interactions in your stories
- All Storybook tests must pass before considering the story complete
- Fix any failing interactions or accessibility issues before proceeding

### Story Organization

#### File Structure for Good Auto-Titles
- Place stories next to components: `ComponentName.stories.tsx`
- Use descriptive directory names that will generate good titles
- Example: `src/presentational-components/shared/UsersRow.stories.tsx` 
  ‚Üí Auto-title: "Presentational Components/Shared/Users Row"

#### Story Naming Conventions
- Use descriptive story names that explain the state/scenario
- Examples: `ActiveUser`, `InactiveUser`, `NoStatus`, `Comparison`
- Avoid generic names like `Default`, `Example`, `Basic`

## Common Pitfalls to Avoid

- ‚ùå Don't use `TableToolbarView` or complex wrappers in stories
- ‚ùå Don't set custom `title` in meta object
- ‚ùå Don't use `console.log` in story event handlers
- ‚ùå **NEVER start the Storybook server** - Always ask the user to handle it

**Goal**: Create focused, realistic, maintainable component stories that serve as documentation and testing tools. Let Storybook handle titles automatically for consistency.

## Autodocs Conflicts and Solutions

### The Problem: MSW Handler Conflicts in Autodocs
When multiple container stories with MSW handlers are rendered simultaneously in autodocs, conflicts occur:
- **MSW Issue**: Multiple handlers for same endpoint cause 500 errors
- **Endless Loading**: Stories get stuck in loading states  
- **Empty Canvas**: Canvas renders but stays blank

### The Solution: Single Autodocs Pattern for Containers

#### ‚ùå WRONG: All stories in autodocs
```typescript
const meta: Meta<typeof Container> = {
  component: Container,
  tags: ['autodocs'],  // ‚ùå All stories render in autodocs = conflicts
};
```

#### ‚úÖ CORRECT: Single story autodocs with directory
```typescript
const meta: Meta<typeof Container> = {
  component: Container,
  tags: ['container-name'],  // ‚úÖ NO autodocs on meta
};

export const Default: Story = {
  tags: ['autodocs'],  // ‚úÖ ONLY default story in autodocs
  parameters: {
    docs: {
      description: {
        story: `
**Default View**: Main container story with full functionality.

## Additional Test Stories

- **[LoadingState](?path=/story/path--loading-state)**: API loading behavior
- **[EmptyState](?path=/story/path--empty-state)**: Empty data handling
- **[ErrorState](?path=/story/path--error-state)**: Error state management
        `,
      },
    },
  },
};

// Other stories: NO docs config, just MSW + tests
export const LoadingState: Story = {
  parameters: {
    msw: { handlers: [...] },  // No conflicts - not in autodocs
  },
};
```

### Benefits of Single Autodocs Pattern
- ‚úÖ **No MSW conflicts** - Only one story renders in autodocs
- ‚úÖ **All stories accessible** - Links provide navigation to all stories  
- ‚úÖ **Clean documentation** - Comprehensive story directory in one place
- ‚úÖ **Reliable testing** - All stories work independently in canvas view

## Redux Integration in Storybook Stories

### CRITICAL: Global Redux Provider Rule
**IMPERATIVE**: NEVER add custom Redux providers in individual stories for ANY reason.

- **Global Provider**: All stories automatically have Redux provider from `.storybook/preview.tsx`
- **FORBIDDEN**: Creating individual `<Provider store={...}>` wrappers in stories
- **FORBIDDEN**: Custom `createStore` or `ReducerRegistry` in individual stories  
- **FORBIDDEN**: Decorators with Redux providers in story files

#### ‚ùå FORBIDDEN: Custom Providers in Stories
```typescript
// DON'T DO THIS - Global provider already exists
const withReduxProvider = (Story) => (
  <Provider store={createStore(reducer)}>
    <Story />
  </Provider>
);

// DON'T DO THIS - No custom decorators with providers
decorators: [withReduxProvider],

// DON'T DO THIS - No manual store creation
const store = createStore(reducer);
```

#### ‚úÖ CORRECT: Use Global Provider + MSW
```typescript
// All stories automatically have Redux provider
export const Story: Story = {
  parameters: {
    msw: {
      handlers: [
        http.get('/api/endpoint/', () => HttpResponse.json(mockData)),
      ],
    },
  },
  play: async ({ canvasElement }) => {
    // Test real API orchestration with global Redux
    await waitFor(() => {
      expect(canvas.getByText('Data')).toBeInTheDocument();
    });
  },
};
```

### Why This Rule Exists
- **Consistency**: All stories use same Redux setup as real app
- **Performance**: No duplicate store creation overhead
- **Maintainability**: Single source of truth for Redux configuration
- **Testing**: Real API orchestration instead of pre-populated stores
- **Architecture**: Matches production Redux provider pattern

### Redux Store Configuration (Legacy Reference)
- **NEVER** use `@reduxjs/toolkit` or `configureStore` - this app uses classic Redux
- **ALWAYS** use `createStore` from the `redux` package for mock stores
- **ALWAYS** match the actual app store structure from `src/redux/`

### Container Stories: API Orchestration vs Store State (CRITICAL)

#### ‚ùå WRONG: Pre-populating Redux with storeState
```typescript
// DON'T DO THIS for container stories
export const ContainerStory: Story = {
  parameters: {
    storeState: {
      userReducer: {
        users: { data: mockUsers },  // Pre-populating Redux
        isLoading: false,
      },
    },
  },
};
```

**Problems with storeState approach:**
- Doesn't test real container responsibility (API orchestration)
- Skips Redux action dispatch and reducer logic
- Creates MSW conflicts in autodocs when multiple stories render
- Doesn't verify the container actually works end-to-end
- **VIOLATES GLOBAL PROVIDER RULE**: Never add custom providers!

#### ‚úÖ CORRECT: Real API Orchestration Testing
```typescript
// DO THIS for container stories
export const ContainerStory: Story = {
  parameters: {
    msw: {
      handlers: [
        http.get('/api/rbac/v1/users/', () => {
          return HttpResponse.json({
            data: mockUsers,
            meta: { count: mockUsers.length },
          });
        }),
      ],
    },
  },
  play: async ({ canvasElement }) => {
    // Test that container dispatches actions and Redux updates
    await waitFor(() => {
      expect(canvas.getByText('john.doe')).toBeInTheDocument();
    });
  },
};
```

**Benefits of API orchestration:**
- Tests complete container responsibility chain
- Verifies Redux actions, reducers, and component integration
- Works cleanly in autodocs (no store conflicts)
- Catches real integration bugs

### Mock Store Creation Pattern (DEPRECATED)
**WARNING**: This pattern is DEPRECATED and FORBIDDEN. Use the global Redux provider instead.

```typescript
// ‚ùå DEPRECATED: Do not use this pattern anymore
import { createStore } from "redux";

const createMockStore = (initialState = {}) => {
  const mockReducer = (state = initialState) => state;
  return createStore(mockReducer);
};

// ‚ùå FORBIDDEN: Custom provider decorators
const withProviders = (Story: StoryFn, context: StoryContext) => {
  // This violates the global provider rule!
  return (
    <Provider store={store}>  {/* NEVER DO THIS */}
      <Story />
    </Provider>
  );
};
```

**Use global provider instead**: All stories automatically have Redux provider from `.storybook/preview.tsx`

### Decorator Pattern for Context Providers (DEPRECATED)
**WARNING**: This pattern is DEPRECATED and FORBIDDEN for Redux providers.

```typescript
// ‚ùå FORBIDDEN: Custom decorators with Redux providers
const meta: Meta<typeof ComponentName> = {
  component: ComponentName,
  decorators: [withProviders], // NEVER DO THIS for Redux
  parameters: {
    storeState: {  // This is also deprecated
      workspaces: mockWorkspaces,
      isLoading: false,
    },
  },
};
```

**Use global provider + MSW instead**: Focus on API testing, not pre-populated stores.

## Chrome Context Enhancement

### Missing Functions in Chrome Mock
When stories fail with "chrome.someFunction is not a function", enhance the Chrome mock:

```typescript
// In .storybook/context-providers.tsx
const mockChrome = {
  // ... existing mock functions
  getUserPermissions: () => Promise.resolve({
    isOrgAdmin: chromeConfig.orgAdmin || false,
    userAccessAdministrator: chromeConfig.userAccessAdministrator || false,
  }),
  // Add other missing functions as needed
};
```

## Modal Testing in Storybook

### Critical Portal Rendering Knowledge
**IMPORTANT**: Modals are rendered to `document.body` via React portals, NOT within the Storybook canvas.

### Correct Modal Testing Pattern
```typescript
import { screen, within } from 'storybook/test';

export const ModalStory: Story = {
  play: async ({ canvasElement, args }) => {
    const canvas = within(canvasElement);
    
    // ‚úÖ Interact with triggers in canvas
    const openButton = canvas.getByRole('button', { name: /open modal/i });
    await userEvent.click(openButton);
    
    // ‚úÖ Find modal content in document.body (via portal)
    const modal = screen.getByRole('dialog');
    expect(modal).toBeInTheDocument();
    
    // ‚úÖ Test modal content using within(modal)
    expect(within(modal).getByText(/modal title/i)).toBeInTheDocument();
    
    // ‚úÖ Test modal interactions
    const confirmButton = within(modal).getByRole('button', { name: /confirm/i });
    await userEvent.click(confirmButton);
    
    // ‚úÖ Verify callbacks were called
    expect(args.onConfirm).toHaveBeenCalled();
  },
};
```

### Common Modal Testing Mistakes
- ‚ùå `canvas.getByRole('dialog')` - Modal not in canvas
- ‚ùå `canvasElement.querySelector('[role="dialog"]')` - Wrong scope
- ‚úÖ `screen.getByRole('dialog')` - Modal is in document.body
- ‚úÖ `within(modal).getByText()` - Scope searches to modal content

### Modal Story Args Requirements  
**Critical**: Modal stories that test callbacks MUST include `args` parameter:
```typescript
play: async ({ canvasElement, args }) => {
  // args is required when testing modal callbacks
  expect(args.onConfirm).toHaveBeenCalled();
}
```

### Container Modal Integration Testing
For container components that manage modal state:
```typescript
export const ModalIntegration: Story = {
  parameters: {
    storeState: { /* Redux state for container */ },
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Trigger action in container UI
    await userEvent.click(canvas.getByRole('button', { name: /delete/i }));
    
    // Modal appears via container state management
    const modal = screen.getByRole('dialog');
    expect(within(modal).getByText(/confirm deletion/i)).toBeInTheDocument();
  },
};
```

## Story Verification Requirements

### ALWAYS Verify Before Continuing
- **REQUIRED**: Test stories immediately after creation using tags
- **REQUIRED**: Fix all failing tests before moving to next component
- **NEVER** create multiple stories without verifying each one works

### Verification Process
1. Add descriptive tags to stories for targeted testing:
   ```typescript
   const meta: Meta<typeof ComponentName> = {
     component: ComponentName,
     tags: ["autodocs", "component-name"], // Add specific tag
   };
   ```

2. Test specific stories with tags:
   ```bash
   npm run test-storybook:ci -- --includeTags="component-name"
   ```

3. Fix any failing tests before proceeding to next component

### IntlMessage Parameter Requirements
- **ALWAYS** check message definitions for required parameters
- **ALWAYS** provide `count` parameter when messages expect it:
  ```typescript
  intl.formatMessage(messages.workspaceNotEmptyWarning, { count: 1 })
  ```

## Common Redux/Storybook Errors and Fixes

### Error: "configureStore is not a function"
- **Cause**: Using Redux Toolkit syntax in non-toolkit app
- **Fix**: Use `createStore` from `redux` package

### Error: "chrome.getUserPermissions is not a function"  
- **Cause**: Incomplete Chrome mock
- **Fix**: Add missing function to `.storybook/context-providers.tsx`

### Error: Missing "count" variable in message
- **Cause**: IntlMessage expects parameters not provided
- **Fix**: Add required parameters to `formatMessage` call


## Testing Library Query Guidelines (MANDATORY)

### Use findBy* Instead of getBy* for Async Content

**CRITICAL RULE**: In Storybook play functions, ALWAYS use `findBy*` and `findAllBy*` queries instead of `getBy*` and `getAllBy*` for better test reliability with async content.

#### ‚ùå WRONG: Synchronous getBy* queries
```typescript
play: async ({ canvasElement }) => {
  const canvas = within(canvasElement);
  
  // ‚ùå Fails immediately if element not found
  expect(canvas.getByText('Loading data...')).toBeInTheDocument();
  expect(canvas.getByRole('button')).toBeInTheDocument();
  
  // ‚ùå Synchronous queries with manual waitFor
  await waitFor(() => {
    expect(canvas.getByText('Data loaded')).toBeInTheDocument();
  });
}
```

#### ‚úÖ CORRECT: Asynchronous findBy* queries  
```typescript
play: async ({ canvasElement }) => {
  const canvas = within(canvasElement);
  
  // ‚úÖ Waits automatically for element to appear
  expect(await canvas.findByText('Loading data...')).toBeInTheDocument();
  expect(await canvas.findByRole('button')).toBeInTheDocument();
  
  // ‚úÖ No waitFor wrapper needed with findBy*
  expect(await canvas.findByText('Data loaded')).toBeInTheDocument();
}
```

### Query Method Guidelines

| Scenario | Use | Don't Use | Reason |
|----------|-----|-----------|---------|
| Single element (async) | `await canvas.findByText()` | `canvas.getByText()` | Waits for async content |
| Multiple elements (async) | `await canvas.findAllByText()` | `canvas.getAllByText()` | Waits for async content |
| Element might not exist | `canvas.queryByText()` | `canvas.getByText()` | Returns null vs throwing |
| Multiple elements that might not exist | `canvas.queryAllByText()` | `canvas.getAllByText()` | Returns [] vs throwing |

### Common Patterns and Fixes

#### Pattern 1: Basic element assertion
```typescript
// ‚ùå Old synchronous pattern
expect(canvas.getByText('Username')).toBeInTheDocument();

// ‚úÖ New asynchronous pattern  
expect(await canvas.findByText('Username')).toBeInTheDocument();
```

#### Pattern 2: Element interaction
```typescript
// ‚ùå Old pattern
const button = canvas.getByRole('button', { name: /submit/i });
await userEvent.click(button);

// ‚úÖ New pattern
const button = await canvas.findByRole('button', { name: /submit/i });
await userEvent.click(button);
```

#### Pattern 3: Row selection with closest()
```typescript
// ‚ùå Wrong: Missing parentheses around await expression
const row = await canvas.findByText('john.doe').closest('tr');

// ‚úÖ Correct: Proper parentheses placement
const row = (await canvas.findByText('john.doe')).closest('tr');
```

#### Pattern 4: Multiple elements
```typescript
// ‚ùå Old pattern
const checkboxes = canvas.getAllByRole('checkbox');
checkboxes.forEach(checkbox => expect(checkbox).toBeChecked());

// ‚úÖ New pattern
const checkboxes = await canvas.findAllByRole('checkbox');
checkboxes.forEach(checkbox => expect(checkbox).toBeChecked());
```

#### Pattern 5: Remove redundant waitFor
```typescript
// ‚ùå Redundant waitFor with findBy*
await waitFor(async () => {
  expect(await canvas.findByText('Success')).toBeInTheDocument();
});

// ‚úÖ findBy* already waits
expect(await canvas.findByText('Success')).toBeInTheDocument();
```

### When to Still Use getBy*

Only use synchronous `getBy*` queries in these specific cases:

1. **Inside within() for already-found elements**:
   ```typescript
   const modal = await screen.findByRole('dialog');
   expect(within(modal).getByText('Title')).toBeInTheDocument(); // OK: modal already exists
   ```

2. **For queryBy* non-existence checks**:
   ```typescript
   expect(canvas.queryByText('Should not exist')).not.toBeInTheDocument(); // OK: testing absence
   ```

3. **When element is guaranteed to exist synchronously**:
   ```typescript
   // OK: Static content that doesn't require API calls
   expect(canvas.getByText('Static Label')).toBeInTheDocument();
   ```

### ESLint Integration

Consider adding these ESLint rules to catch `getBy*` usage in stories:

```json
{
  "rules": {
    "testing-library/prefer-find-by": "error",
    "testing-library/no-await-sync-query": "error"
  }
}
```

### Performance Benefits

- **Faster tests**: No artificial `setTimeout` delays
- **More reliable**: Built-in retry mechanism handles timing issues  
- **Cleaner code**: Less `waitFor` boilerplate
- **Better errors**: More descriptive failure messages

### Handling Multiple Elements with Scoping

When text appears in multiple places (bundle cards, table content, filter dropdowns), use scoping to target specific areas:

#### ‚ùå WRONG: Global search finds multiple elements
```typescript
// Fails: "Found multiple elements with the text: advisor"
expect(await canvas.findByText('advisor')).toBeInTheDocument();
```

#### ‚úÖ CORRECT: Scope search to specific container
```typescript
// Target specific table content only
const table = await canvas.findByRole('grid', { name: /permissions table/i });
const tableContent = within(table);
expect(await tableContent.findByText('advisor')).toBeInTheDocument();

// Or target specific menu content only
const menu = await canvas.findByRole('menu');
const menuContent = within(menu);
expect(await menuContent.findByText('advisor')).toBeInTheDocument();
```

#### Common Scoping Patterns
```typescript
// 1. Table content scoping
const table = await canvas.findByRole('grid');
expect(await within(table).findByText('data')).toBeInTheDocument();

// 2. Modal content scoping
const modal = screen.getByRole('dialog');
expect(within(modal).getByText('title')).toBeInTheDocument();

// 3. Bundle card scoping
const bundleCard = await canvas.findByText('Red Hat Enterprise Linux').closest('.pf-v5-c-card');
expect(within(bundleCard).getByText('advisor')).toBeInTheDocument();

// 4. Dropdown menu scoping
const menu = await canvas.findByRole('menu');
expect(await within(menu).findByLabelText(/option/i)).toBeInTheDocument();
```

## Critical Storybook Testing Rules

### NEVER Guess - ALWAYS Ask for Guidance
**MANDATORY**: When you don't understand how something works (API parameters, component behavior, etc.), ALWAYS ask for guidance instead of guessing.

```typescript
// ‚ùå NEVER guess at API parameter names
const username = url.searchParams.get('username') || 
                 url.searchParams.get('principal_username') || 
                 url.searchParams.get('name') ||
                 url.searchParams.get('user'); // Multiple guesses!

// ‚úÖ ALWAYS ask: "What parameter name does the API use for filtering?"
const usernames = url.searchParams.get('usernames'); // Correct parameter from guidance

// ‚ùå NEVER guess at expected values
expect(sortSpy).toHaveBeenCalledWith('-username'); // Guessing format

// ‚úÖ ALWAYS ask: "What values does the sorting API expect?"  
expect(sortSpy).toHaveBeenCalledWith('desc'); // Correct value from guidance
```

**Why this matters:**
- Guessing wastes time and creates incorrect tests
- API contracts are specific - wrong parameters fail silently
- Component behavior varies - assumptions lead to broken tests
- **ASK, don't guess** - it's faster and more reliable

### NEVER Use getBy* in Play Functions
**MANDATORY**: Always use `findBy*` instead of `getBy*` in Storybook play functions for better async handling.

```typescript
// ‚ùå NEVER do this in play functions
const button = canvas.getByRole('button');
const text = canvas.getByText('Hello');

// ‚úÖ ALWAYS use findBy* for async content
const button = await canvas.findByRole('button');
const text = await canvas.findByText('Hello');
```

## PatternFly Component Testing Patterns

### PatternFly Table Role Requirements
**CRITICAL**: PatternFly tables use `role="grid"`, not `role="table"`.

#### Table Testing Patterns
```typescript
// ‚úÖ PatternFly tables render with role="grid" - use findBy for async
const table = await canvas.findByRole('grid'); // Correct for PatternFly tables

// ‚ùå Don't use role="table" for PatternFly components
const table = await canvas.findByRole('table'); // Wrong for PatternFly tables

// ‚ùå NEVER use getBy* in play functions - always use findBy*
const table = canvas.getByRole('grid'); // Wrong - use findBy instead

// ‚úÖ Fallback pattern for when unsure about table type
const table = (await canvas.findByRole('grid').catch(() => null)) || 
               (await canvas.findByRole('table'));
```

#### Expandable Row Testing Patterns
**CRITICAL**: For testing expandable rows in PatternFly tables, scope queries to the nested content.

##### Single Expandable Cell Pattern
```typescript
// ‚úÖ Testing single expandable row content - scope to nested table
export const ExpandedRowStory: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Click to expand a row (e.g., permissions count link)
    const expandLink = await canvas.findByText('5'); // or findByRole('button', { name: /expand/i })
    await userEvent.click(expandLink);
    
    // Scope queries to the nested content within the expanded row
    const expandedRow = within(expandLink.closest('tbody').querySelector('table'));
    
    // Test nested table headers and content within the scoped area
    expect(await expandedRow.findByText('Application')).toBeInTheDocument();
    expect(await expandedRow.findByText('Resource type')).toBeInTheDocument();
    expect(await expandedRow.findByText('Operation')).toBeInTheDocument();
    
    // Test data within the nested table only
    expect(await expandedRow.findByText('advisor')).toBeInTheDocument();
    expect(await expandedRow.findByText('compliance')).toBeInTheDocument();
  },
};
```

##### Multiple Compound Expandable Cells Pattern
**CRITICAL**: When a row contains **multiple compound expandable cells** (e.g., both Groups and Permissions), use semantic targeting to distinguish between nested tables:

```typescript
// ‚úÖ CORRECT: Multiple compound expandables in same row
export const MultipleExpandableStory: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Test groups expandable
    const groupsButton = await canvas.findByRole('button', { name: '3' });
    const row = within(groupsButton.closest('tbody') as HTMLElement);
    await userEvent.click(groupsButton);
    
    // Use semantic targeting to find correct nested table
    const groupsTable = within(await row.findByLabelText('Compound groups table'));
    expect(await groupsTable.findByText('Group name')).toBeInTheDocument();
    expect(await groupsTable.findByText('Description')).toBeInTheDocument();
    
    // Test permissions expandable (same row, different table)
    const permissionsButton = await canvas.findByRole('button', { name: '25' });
    await userEvent.click(permissionsButton);
    
    const permissionsTable = within(await row.findByLabelText('Compound permissions table'));
    expect(await permissionsTable.findByText('Application')).toBeInTheDocument();
    expect(await permissionsTable.findByText('Resource type')).toBeInTheDocument();
    expect(await permissionsTable.findByText('Operation')).toBeInTheDocument();
  },
};

// ‚ùå WRONG: DOM traversal finds first table regardless of button
const table = within(button.closest('tbody').querySelector('table')); // Always finds first table!

// ‚úÖ CORRECT: Semantic targeting distinguishes between tables
const table = within(await row.findByLabelText('Compound groups table')); // Specific table
```

**This pattern applies when:**
- ‚úÖ Multiple compound expandables exist in the same row
- ‚úÖ All nested tables have distinct `aria-label` attributes  
- ‚úÖ Tables exist simultaneously (not conditionally rendered)

**Progressive Scoping Strategy:**
1. **Create logical container scope**: `within(button.closest('tbody'))`
2. **Find semantic element within scope**: `await row.findByLabelText('Compound groups table')`
3. **Test content within semantic scope**: `await groupsTable.findByText('Group name')`

### Semantic Targeting Priority

#### Priority Order for Element Selection
Use this hierarchy when choosing selectors (most preferred to least):

1. **Semantic roles**: `findByRole('grid')`, `findByLabelText('aria-label')`
2. **Accessible text**: `findByText()`, `findByDisplayValue()`  
3. **DOM traversal**: `closest()` + `querySelector()` (last resort)

```typescript
// ‚úÖ BEST: Semantic targeting with aria-labels
const table = within(await row.findByLabelText('Compound permissions table'));

// ‚úÖ GOOD: Role-based targeting  
const table = await canvas.findByRole('grid', { name: /permissions/i });

// ‚úÖ ACCEPTABLE: Text-based targeting
const table = await canvas.findByText('Permissions').closest('table');

// ‚ùå FRAGILE: DOM traversal only when necessary
const table = within(button.closest('td')?.querySelector('table'));
```

#### Benefits of Semantic Targeting
- **More resilient** to DOM structure changes
- **Better accessibility** testing coverage  
- **Clearer intent** - shows what user is looking for
- **Less brittle** than CSS selector chains

// ‚ùå Don't search globally - may find text elsewhere in the DOM
const text = await canvas.findByText('Application'); // Wrong - too broad

// ‚úÖ Always scope to the specific expanded content
const expandedRow = within(triggerElement.closest('tbody').querySelector('table'));
const text = await expandedRow.findByText('Application'); // Correct - scoped search

### Modal Testing Requirements
**CRITICAL**: For modal testing, add a button to open the modal with a simple label.

#### Modal Story Pattern
```typescript
export const ModalStory: Story = {
  args: {
    isOpen: false, // Start with modal closed
  },
  play: async ({ canvasElement, args }) => {
    const canvas = within(canvasElement);
    
    // Add a simple button to open the modal
    const openButton = canvas.getByRole('button', { name: 'Open Modal' });
    await userEvent.click(openButton);
    
    // Modal renders to document.body via portal
    const modal = screen.getByRole('dialog');
    expect(modal).toBeInTheDocument();
    
    // Test modal content using within(modal)
    expect(within(modal).getByText('Modal Title')).toBeInTheDocument();
  },
};
```

#### Modal Button Labels
Keep button labels simple for easy testing:
- ‚úÖ "Open Modal", "Edit Item", "Delete User"
- ‚ùå "Click here to open the advanced configuration modal dialog"

### Filter Testing Patterns
**CRITICAL**: For testing PatternFly filter components, use proper scoping and test real UI behavior.

#### Filter Interaction Pattern
```typescript
export const FilterStory: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Step 1: Open filter dropdown by text content (not aria-label)
    const filterButton = await canvas.findByText('Filter by application');
    await userEvent.click(filterButton);
    
    await delay(200); // Give dropdown time to open
    
    // Step 2: Double scoping for complex interactions
    const menu = await canvas.findByRole('menu');
    const menuContent = within(menu);
    
    // Step 3: Target specific menuitem, then the checkbox within it
    const advisorMenuItem = await menuContent.findByRole('menuitem', { name: /advisor/i });
    const advisorCheckbox = within(advisorMenuItem).getByRole('checkbox');
    await userEvent.click(advisorCheckbox);
    
    await delay(300); // Wait for API call
    
    // Step 4: Test REAL UI behavior, not assumptions
    // ‚úÖ Use length assertions when elements appear in multiple contexts
    expect(await canvas.findAllByText('advisor')).toHaveLength(3); 
    // 1. in the menu, 2. in the filter chips, 3. in the table
    
    // ‚úÖ Other filter options remain in dropdown (don't disappear)
    expect(canvas.queryByText('compliance')).toHaveLength(1);
    expect(canvas.queryByText('vulnerability')).toHaveLength(1);
  },
};
```

#### Filter Testing Key Principles

**Double Scoping Pattern**: For complex nested interactions
```typescript
// ‚úÖ Scope to container, then to specific element
const menu = await canvas.findByRole('menu');
const menuContent = within(menu);
const menuItem = await menuContent.findByRole('menuitem', { name: /option/i });
const checkbox = within(menuItem).getByRole('checkbox');
```

**Real UI Behavior Testing**: Test what actually happens, not assumptions
```typescript
// ‚ùå Don't assume filtered options disappear completely
expect(canvas.queryByText('compliance')).not.toBeInTheDocument(); // Wrong

// ‚úÖ Test actual behavior - options remain in filter dropdown
expect(canvas.queryByText('compliance')).toHaveLength(1); // Correct
```

**Length Assertions**: When text appears in multiple UI contexts
```typescript
// ‚úÖ When filtering, text may appear in: dropdown, filter chips, and results
expect(await canvas.findAllByText('advisor')).toHaveLength(3);

// ‚ùå Don't use simple presence/absence when there are multiple instances
expect(await canvas.findByText('advisor')).toBeInTheDocument(); // Wrong - multiple elements
```

**OUIA vs TestId**: Different attributes require different selectors
```typescript
// ‚ùå Wrong - findByTestId looks for data-testid, not data-ouia-component-id
const element = await canvas.findByTestId('Filter by application');

// ‚úÖ Correct approaches for OUIA components
const element = await canvas.findByText('Filter by application');
const element = await canvas.findByRole('menu');
```

### Migration Checklist

When updating existing stories:

- [ ] Replace `canvas.getByText()` with `await canvas.findByText()`
- [ ] Replace `canvas.getAllByText()` with `await canvas.findAllByText()`  
- [ ] Replace `screen.getByRole()` with `await screen.findByRole()`
- [ ] Replace `canvas.getByRole('table')` with `canvas.getByRole('grid')` for PatternFly tables
- [ ] Add parentheses around `await` expressions before `.closest()`: `(await canvas.findByText()).closest()`
- [ ] Remove redundant `waitFor()` wrappers around `findBy*` queries
- [ ] Make `waitFor` callbacks `async` if they contain `await` expressions
- [ ] Remove unused `waitFor` imports when no longer needed

## üîí MANDATORY PRE-FLIGHT CHECKLIST FOR AI

**BEFORE creating or editing ANY .stories.tsx file, I MUST verify:**

### Import Verification
- [ ] ‚úÖ Using `storybook/test` imports (NOT @storybook/test)
- [ ] ‚úÖ All testing utilities imported from single source

### Query Pattern Verification  
- [ ] ‚úÖ ALL queries in play functions use `await canvas.findBy*()` 
- [ ] ‚úÖ NO `canvas.getBy*()` queries in play functions
- [ ] ‚úÖ Modal testing uses `screen.getByRole('dialog')`
- [ ] ‚úÖ PatternFly tables use `role="grid"`, not `role="table"`

### Story Structure Verification
- [ ] ‚úÖ Container stories: Meta has NO autodocs, Default story ONLY has autodocs
- [ ] ‚úÖ Presentational stories: All stories have autodocs
- [ ] ‚úÖ MSW handlers used instead of storeState for containers
- [ ] ‚úÖ Args parameter kept if story uses it, removed if not

### Play Function Verification
- [ ] ‚úÖ ALL `expect()` calls are awaited: `await expect(...)`
- [ ] ‚úÖ User interactions test real workflows, not just events
- [ ] ‚úÖ Loading states test for skeleton elements
- [ ] ‚úÖ Proper scoping used for complex components

### API Spy Testing Verification (For Container Stories)
- [ ] ‚úÖ API spies created with `const apiSpy = fn()` pattern
- [ ] ‚úÖ Spies called inside MSW handlers with meaningful parameters
- [ ] ‚úÖ Spy assertions use `expect(apiSpy).toHaveBeenCalledWith({ params })`
- [ ] ‚úÖ Multiple API calls tested with `toHaveBeenCalledTimes(n)`
- [ ] ‚úÖ Async spy testing wrapped in `waitFor()` when needed

### React-Data-View Verification (For DataView Components)
- [ ] ‚úÖ BulkSelect imported from `@patternfly/react-component-groups`, NOT react-core
- [ ] ‚úÖ useDataViewSelection hook includes `matchOption: (a, b) => a.id === b.id`
- [ ] ‚úÖ DataView selection prop is conditional: `selection={hasPermissions ? selection : undefined}`
- [ ] ‚úÖ BulkSelect handler passes `tableRows` not raw data: `selection.onSelect(true, tableRows)`
- [ ] ‚úÖ Toolbar actions are conditional based on selection state
- [ ] ‚úÖ Row actions column included for admin users with proper kebab menus
- [ ] ‚úÖ Filtering uses debounced handlers and proper API integration
- [ ] ‚úÖ Testing covers bulk select, toolbar actions, row actions, and filtering

### Empty States Verification (CRITICAL)
- [ ] ‚úÖ Empty state component receives `hasActiveFilters` prop to determine state type
- [ ] ‚úÖ NO RESULTS state uses SearchIcon and "No items match your search" message
- [ ] ‚úÖ NO DATA state uses domain icon (UsersIcon, CubesIcon) and "Configure items" message  
- [ ] ‚úÖ Empty state wrapped in proper table structure: `<Tbody><Tr><Td colSpan={colSpan}>`
- [ ] ‚úÖ colSpan matches actual table column count dynamically
- [ ] ‚úÖ No-data state includes create button for admin users with permissions
- [ ] ‚úÖ Testing covers both empty state types: EmptyState and NoResultsAfterFilter stories
- [ ] ‚úÖ Loading state testing shows skeletons, NOT empty states

**I MUST NOT proceed without completing this checklist for every .stories.tsx file.**


