---
type: always
description: "General development guidelines and project standards for the RBAC UI React application, including file organization, naming conventions, and workflow rules."
---

# RBAC UI Project - General Development Rules
## Quick Reference (AI Priority)

### File Operations
| Operation | Rule | Pattern |
|-----------|------|---------|
| Case changes | Create new → Delete old → Stage both | `git add NewFile.tsx && git rm oldfile.js` |
| Git operations | NEVER do unless requested | Focus on code only |
| Component files | CamelCase.tsx | `ComponentName.tsx` |
| Other files | lowerCamelCase | `helperFunction.js` |

### Build Commands
```bash
npm run build       # Production build - verify before commit
npm run lint:js     # Linting - must pass
npm run build-storybook   # Storybook build
npm test           # Test suite
npm run test-storybook:ci # Storybook Test suite
```

### Architecture Quick Map
```
src/
├── smart-components/           # Feature containers (route-tied)
├── presentational-components/  # Reusable UI components  
├── helpers/                   # Business logic by feature
└── redux/                     # State management
```

## Critical Rules Checklist

### ❌ NEVER DO
- [ ] Run git commands unless explicitly requested
- [ ] Use case changes without proper Git staging
- [ ] Ignore build/lint failures
- [ ] Mix file naming conventions
- [ ] **REFACTOR IN-PLACE** - Never modify existing working components directly
- [ ] Delete/modify working components during refactoring
- [ ] Trust that existing TypeScript types are 100% accurate

### ✅ ALWAYS DO  
- [ ] Check `package.json` for dependency versions first
- [ ] Use proper file naming: CamelCase for components, lowerCamelCase for others
- [ ] Stage both old/new files for case changes
- [ ] Verify changes with build commands
- [ ] **USE SIDE-BY-SIDE DEVELOPMENT** - Always create new components alongside existing ones
- [ ] **COPY AND ADAPT STORIES** - Migrate test coverage to prove functional equivalence
- [ ] **VERIFY BEFORE SWITCHING** - Only replace working components after full validation


## Project Context

This is a React-based UI application for Red Hat's Role-Based Access Control (RBAC) system, built with:
- **React** for UI components  
- **PatternFly** for design system and components
- **TypeScript** for type safety
- **Storybook** for component documentation and testing
- **Redux** for state management

## Development Workflow

### JavaScript to TypeScript Conversion Process (MANDATORY)

**CRITICAL**: ALL conversion from JavaScript to TypeScript work MUST use side-by-side development, not in-place modification.

**The Process**:
1. **Rename existing JS file to -legacy.js** - Keep original working (e.g., `userTable.js` → `userTable-legacy.js`)
2. **Create Storybook file for legacy component** - Document current behavior (`UserTable-legacy.stories.tsx`)
3. **Create new TypeScript implementation** - Use proper casing (`UserTable.tsx`)
4. **Copy and adapt stories** - Migrate test coverage to new implementation (`UserTable.stories.tsx`)
5. **Verify functional equivalence** - Ensure all stories pass with new component
6. **Switch when confident** - Update imports to use new TypeScript component
7. **Clean up** - Remove -legacy files only after successful switch

**Example Workflow**:
```bash
# ❌ WRONG - In-place modification
# Modifying src/components/userTable.js directly

# ✅ CORRECT - Side-by-side development  
# 1. Rename existing to legacy
mv src/components/userTable.js src/components/userTable-legacy.js

# 2. Create stories for legacy (document current behavior)
# Create: src/components/UserTable-legacy.stories.tsx

# 3. Create new TypeScript implementation (proper casing)
# Create: src/components/UserTable.tsx

# 4. Copy and adapt stories for new implementation
# Create: src/components/UserTable.stories.tsx (copied from UserTable-legacy.stories.tsx)

# 5. Verify equivalence through stories
npm run test-storybook:ci -- "UserTable.stories.tsx"

# 6. Switch when confident (update imports)
# 7. Remove legacy files
```

**Why This Process**:
- ✅ **Zero Risk** - Original stays working during development
- ✅ **Easy Rollback** - Can revert quickly if issues found  
- ✅ **Proper Testing** - Stories verify functional equivalence
- ✅ **Confidence** - Full validation before switching
- ✅ **No Regressions** - Maintains stability throughout process

**This Process Applies To**:
- **JavaScript to TypeScript conversions** (primary use case)
- **Component architecture refactoring** when changing file structure
- **Major API integration changes** that affect component signatures
- **react-data-view migrations** from TableToolbarView
- **Any change that might break existing functionality**

### Never Perform Git Operations
- **CRITICAL**: Never run git commands or suggest git workflows unless explicitly requested
- Don't create commits, branches, or any git operations
- Don't run git commands or suggest git workflows  
- Focus only on code changes and file modifications
- Let user handle all version control operations

### File Case Changes (CRITICAL)
- **ALWAYS** handle case changes properly to avoid IDE confusion
- When renaming files with case changes (e.g., `toolbar.js` → `Toolbar.tsx`):
  1. Create the new file with correct case
  2. Delete the old file with wrong case
  3. **MUST** stage both changes: `git add newfile.tsx` and `git rm oldfile.js`
  4. This prevents IDE confusion where Git tracks old file as deleted while new file is untracked
- Case changes without proper Git staging cause IDE save issues and file tracking problems

### Investigation Process
1. Check dependency versions in `package.json` first
2. Understand component's role and data requirements
3. Look for existing patterns in similar components
4. Use PatternFly documentation for component APIs
5. Verify changes with build/lint commands

### Building and Testing
- `npm run build` - Production build
- `npm run lint:js` - JavaScript/TypeScript linting
- `npm run storybook` - Start Storybook development server
- `npm test` - Run test suite

## MANDATORY VALIDATION CHECKLIST

### ❌ NEVER MARK WORK AS COMPLETE WITHOUT RUNNING ALL VALIDATION COMMANDS

**CRITICAL**: Before claiming any task is "COMPLETED", "DONE", "FINISHED", or similar, you MUST run and verify ALL of the following commands pass successfully:

### Required Validation Commands (MUST RUN ALL)
```bash
# 1. TypeScript compilation check
npm run build

# 2. Linting check  
npm run lint:js

# 3. Test suite
npm test

# 4. Storybook test suite
npm run test-storybook:ci
```

### Validation Rules
- **ALL commands must pass with exit code 0**
- **NO warnings or errors allowed** - any failures mean work is NOT complete
- **Run commands in sequence** - don't claim completion until all pass
- **If any command fails** - fix the issues and re-run ALL commands
- **Only after ALL commands pass** - then and only then can work be marked complete

### What This Prevents
- ❌ Claiming "COMPLETED" when build fails
- ❌ Claiming "SUCCESS" when linting has errors  
- ❌ Claiming "DONE" when tests are broken
- ❌ Claiming "FINISHED" when Storybook tests fail
- ❌ Any premature completion declarations

### What This Ensures
- ✅ Code actually compiles
- ✅ Code passes all linting rules
- ✅ All tests pass
- ✅ Storybook stories work correctly
- ✅ Work is truly complete and functional

**REMEMBER**: The user has repeatedly had to remind AI to run these validation commands. This rule exists because AI has a pattern of claiming completion without proper validation. Follow this rule religiously.

## Architecture

### Key Directories
- `src/smart-components/` - Feature-based component organization
  - `access-management/` - User and group access management
  - `group/` - Group management functionality
  - `role/` - Role management functionality
  - `user/` - User management functionality
  - `workspaces/` - Workspace management functionality
- `src/presentational-components/` - Reusable UI components
- `src/helpers/` - Business logic by feature area
- `src/redux/` - State management (actions, reducers)

### File Naming Conventions (REQUIRED)
- Components: `ComponentName.js/tsx` (MUST be capitalized and reflect component name)
- Stories: `ComponentName.stories.tsx` (MUST be capitalized and reflect component name)
- Tests: `ComponentName.test.js` (MUST be capitalized and reflect component name)
- Styles: `ComponentName.scss` (MUST be capitalized and reflect component name)
- All the rest: `lowerCamelCase.xyz` (MUST be lowerCamelCase)

This project follows Red Hat's frontend development standards and integrates with the Red Hat Cloud Services platform.
