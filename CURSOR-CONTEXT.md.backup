# Storybook Story Development - Quick Reference

*External quick reference for Cursor AI development - Full guide available in Storybook*

> **üìñ Complete Guide:** The comprehensive guide with all enhanced features is available in Storybook at `Documentation/Storybook Guide`. This file serves as a quick external reference for Cursor development.

## **üéØ Story Development Principles**

### **Focus on the Component, Not Wrappers**
- ‚úÖ Stories should document the **actual component** being developed
- ‚ùå Don't let stories document complex wrapper components (like `TableToolbarView`)
- ‚úÖ Use Storybook's **autotitle feature** - don't set custom `title` in meta
- ‚úÖ Set `component: ActualComponent` in meta object

### **Story Structure Best Practices**
```typescript
const meta: Meta<typeof ComponentName> = {
  component: ComponentName,  // The actual component being documented
  // No title - let Storybook auto-generate from file path
  tags: ['autodocs'],
  parameters: {
    docs: {
      description: {
        component: `Clear description of what the component does and how it works`
      }
    }
  }
};
```

### **Story Ordering Best Practices**
- ‚úÖ **Always make comparison stories the default** when creating them
- ‚úÖ Comparison stories show all component states at once - much more useful than individual states
- ‚úÖ Name comparison stories as the first export: `export const StateComparison: Story = { ... }`
- ‚úÖ Individual state stories should come after the comparison story
- ‚úÖ This gives developers immediate overview of component behavior

## **‚ö†Ô∏è Development Workflow Rules**

### **Git & Version Control**
- ‚ùå **NEVER touch git operations unless explicitly asked by the user**
- ‚ùå Don't create commits, branches, or any git operations
- ‚ùå Don't run git commands or suggest git workflows
- ‚úÖ Focus only on code changes and file modifications
- ‚úÖ Let the user handle all version control operations

## **üîß PatternFly Integration Patterns**

### **Table Row Wrappers**
- ‚úÖ Use `RowWrapperProps` interface from PatternFly
- ‚úÖ Implement as: `({ row, ...props }: RowWrapperProps) => JSX.Element`
- ‚úÖ Use complete `Table` structure in stories:
```typescript
<Table aria-label="Description" cells={columns} rowWrapper={Component} rows={data}>
  <TableHeader />
  <TableBody />
</Table>
```

### **TypeScript Compatibility**
- ‚úÖ Import proper PatternFly types: `import { RowWrapperProps } from '@patternfly/react-table'`
- ‚úÖ Use type assertions when needed: `args.row!` for story arguments
- ‚úÖ Ensure component return types match PatternFly expectations

## **üìä Data Structure Understanding**

### **Know Your Component's Data Dependencies**
- ‚úÖ Understand what data the component **actually reads** from props
- ‚úÖ For table components, understand the expected row structure
- ‚úÖ Example: `UsersRow` reads `row.status.props['data-is-active']`, not `row.cells`

### **Realistic vs Mock Data**
- ‚úÖ Use **realistic data structures** that match production usage
- ‚úÖ Include actual PatternFly components (Labels, Icons, etc.) in cell data
- ‚ùå Don't use generic mock data that doesn't reflect real usage
- ‚úÖ Add `key` props to JSX elements in arrays

## **üö´ Common Pitfalls to Avoid**

### **Complex Story Wrappers**
- ‚ùå Don't use `TableToolbarView` or similar complex components in stories
- ‚ùå Avoid components that cause React hooks issues
- ‚úÖ Use minimal, focused wrappers that showcase the component

### **TypeScript Issues**
- ‚ùå Don't create overly restrictive custom interfaces when PatternFly types exist
- ‚ùå Don't ignore TypeScript errors - fix them with proper types
- ‚úÖ Use PatternFly's provided interfaces and extend them if needed

### **Data Structure Mismatches**
- ‚ùå Don't assume component uses `cells` array if it doesn't
- ‚ùå Don't create data structures that don't match component expectations
- ‚úÖ Trace through component code to understand actual data flow

### **Story Titles**
- ‚ùå Don't set custom `title` in meta object
- ‚úÖ Let Storybook auto-generate titles from file path structure
- ‚úÖ Organize files in logical directory structure for good auto-titles

## **üé≠ Storybook Actions & Event Handling**

### **Automatic Actions Configuration**
- ‚úÖ Actions are **automatically configured** for all `on*` props via:
  ```typescript
  // In .storybook/preview.tsx
  parameters: {
    actions: { argTypesRegex: '^on.*' },
  }
  ```
- ‚úÖ This automatically logs `onClick`, `onChange`, `onSubmit`, etc. to Actions panel
- ‚úÖ **Props that are callbacks (starting with `on`) don't need manual `action()` calls**
- ‚ùå **Don't use `console.log`** in story event handlers

### **Manual Action Usage**
```typescript
import { action } from 'storybook/actions';

// Use descriptive action names for clear debugging
export const Example: Story = {
  args: {
    title: 'Button example',
    actions: (
      <Button onClick={action('create-group')}>Create Group</Button>
    ),
  },
};
```

### **Action Best Practices**
- ‚úÖ Use **descriptive action names**: `action('create-group')`, `action('clear-filters')`
- ‚úÖ Action names help identify which interaction triggered in Actions panel
- ‚úÖ Replace any existing `console.log` handlers with `action()` calls
- ‚ùå Don't use generic names like `action('click')` or `action('button')`

### **Play Functions for Testing onClick Behavior**
```typescript
import { userEvent, within, expect, fn } from 'storybook/test';

// Individual stories use fn() for testable spies
export const ClickableStory: Story = {
  args: {
    onClick: fn(),  // Testable spy function
    // ... other args
  },
  play: async ({ canvasElement, args }) => {
    const canvas = within(canvasElement);
    
    // Click specific element with selector for precision
    await userEvent.click(canvas.getByText('5', { selector: 'a' }));
    
    // Assert onClick was called
    await expect(args.onClick).toHaveBeenCalled();
  }
};

// Test negative cases (non-clickable elements)
export const NonClickableStory: Story = {
  args: {
    onClick: fn(),
    // ... args that result in non-clickable state
  },
  play: async ({ canvasElement, args }) => {
    const canvas = within(canvasElement);
    
    // Verify element type and state
    const naText = canvas.getByText('N/A');
    await expect(naText.tagName).toBe('SPAN');
    
    // Assert onClick was NOT called
    await expect(args.onClick).not.toHaveBeenCalled();
  }
};
```

### **Play Function Guidelines**
- ‚úÖ **Use `fn()` for individual stories** - creates testable spy functions
- ‚úÖ **Use specific selectors** - `{ selector: 'a' }` to target exact elements
- ‚úÖ **Test both positive and negative cases** - when onClick should/shouldn't be called
- ‚úÖ **Test element types** - verify spans vs links vs buttons
- ‚ùå **Never add play functions to comparison stories** - they're for visual comparison only
- ‚ùå **Don't test StateComparison stories** - focus on individual story behavior

## **üîÑ JavaScript to TypeScript Conversion Workflow**

### **Recommended Conversion Process**
1. **Document first**: Create Storybook stories for the JS component
2. **Test behaviors**: Use stories to understand all component states/props
3. **Add play functions**: Test interactive behaviors if component has logic
4. **Convert to TypeScript**: Transform `.js` ‚Üí `.tsx` with proper types
5. **Verify**: Ensure stories still work and tests pass

### **TypeScript Conversion Best Practices**
```typescript
// Before (JavaScript)
const StatusLabel = ({ isOrgAdmin, isUserAccessAdmin }) => {
  // component logic
};

StatusLabel.propTypes = {
  isOrgAdmin: PropTypes.bool,
  isUserAccessAdmin: PropTypes.bool,
};

// After (TypeScript)
interface StatusLabelProps {
  isOrgAdmin?: boolean;
  isUserAccessAdmin?: boolean;
}

const StatusLabel: React.FC<StatusLabelProps> = ({ isOrgAdmin, isUserAccessAdmin }) => {
  // component logic - keep exact same behavior
};
```

### **Conversion Guidelines**
- ‚úÖ **Preserve exact behavior** - don't "improve" logic during conversion
- ‚úÖ **Remove PropTypes** - replace with TypeScript interface
- ‚úÖ **Use `React.FC<Props>`** for function components
- ‚úÖ **Keep original file structure** and imports (except PropTypes)
- ‚úÖ **Verify stories still work** after conversion
- ‚ùå Don't change component logic during TS conversion
- ‚ùå Don't add new features during conversion - just add types

### **Common TypeScript Patterns**
```typescript
// Optional props with defaults
interface ComponentProps {
  required: string;
  optional?: boolean;
  callback?: () => void;
}

// Extending existing interfaces
interface ExtendedProps extends BaseProps {
  additionalProp: string;
}

// Event handlers
interface ButtonProps {
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
}
```

## **‚úÖ Quality Checklist**

### **Before Submitting Stories:**
- [ ] **Verified dependency versions** in `package.json` and used correct documentation
- [ ] Stories document the target component, not wrappers
- [ ] No custom `title` in meta (using autotitle)
- [ ] All TypeScript errors resolved
- [ ] `npm run build` passes
- [ ] `npm run lint:js` passes (no errors, warnings OK)
- [ ] Realistic data structures used
- [ ] PatternFly components properly integrated
- [ ] JSX elements in arrays have `key` props
- [ ] Stories show different component states/behaviors

### **Component Development:**
- [ ] **Checked dependency versions** for accurate API usage
- [ ] Uses appropriate PatternFly interfaces
- [ ] Handles undefined/missing data gracefully
- [ ] Returns correct type expected by PatternFly
- [ ] Follows existing codebase patterns
- [ ] Properly typed with TypeScript

## **üîÑ Investigation Process**

### **When Working with Existing Components:**
1. **Check dependency versions** - Look at `package.json` for PatternFly, React, and other library versions to use correct documentation
2. **Understand the component's role** - Is it a wrapper? What does it wrap?
3. **Check actual usage** - Look at how it's used in the codebase
4. **Understand data flow** - What data does it actually read/use?
5. **Check PatternFly patterns** - What interfaces should it implement? (Use version-specific docs)
6. **Verify with build/lint** - Ensure changes don't break anything

### **When Creating Stories:**
1. **Check dependency versions first** - Ensure using correct Storybook and PatternFly documentation
2. **Focus on the component** - Not the ecosystem around it
3. **Use realistic data** - Match production data structures
4. **Test edge cases** - Active/inactive, missing data, undefined states
5. **Keep it simple** - Minimal wrapper, maximum component focus

### **Version-Specific Documentation Sources:**
- **PatternFly React**: Check version in `package.json`, then use corresponding docs
  - Example: `@patternfly/react-table@4.x.x` vs `@patternfly/react-table@5.x.x` have different APIs
- **Storybook**: Use version-specific documentation for story formats and meta configurations
- **React**: Ensure patterns match the React version being used
- **TypeScript**: Check for version-specific type definitions and features

## **üìù Key Technical Patterns**

### **Row Wrapper Pattern:**
```typescript
const ComponentRow = ({ row, ...props }: RowWrapperProps) => {
  const { relevantData } = row || {};
  const computedValue = relevantData?.nested?.property;
  return <RowWrapper className={classNames('base-class', { 'conditional-class': computedValue })} row={row} {...props} />;
};
```

### **Story Pattern for Table Components:**
```typescript
export const StoryName: Story = {
  render: (args) => (
    <Table aria-label="Table description" cells={columns} rowWrapper={Component} rows={[args.row!]}>
      <TableHeader />
      <TableBody />
    </Table>
  ),
  args: {
    row: {
      uuid: 'unique-id',
      cells: [<Component key="cell">Content</Component>, 'data', 'more data'],
      expectedProperty: { nested: { data: true } }
    }
  }
};
```

### **Basic Story Meta Pattern:**
```typescript
import React from 'react';
import type { Meta, StoryObj } from '@storybook/react-webpack5';
import ComponentName from './ComponentName';

const meta: Meta<typeof ComponentName> = {
  component: ComponentName,
  tags: ['autodocs'],
  parameters: {
    docs: {
      description: {
        component: `
Component description explaining:
- What it does
- How it's used
- Expected data structure
- Any special behaviors
        `,
      },
    },
  },
};

export default meta;
type Story = StoryObj<typeof ComponentName>;
```

## **üé® Story Organization**

### **File Structure for Good Auto-Titles**
- Place stories next to components: `ComponentName.stories.tsx`
- Use descriptive directory names that will generate good titles
- Example: `src/presentational-components/shared/UsersRow.stories.tsx` 
  ‚Üí Auto-title: "Presentational Components/Shared/Users Row"

### **Story Naming Conventions**
- Use descriptive story names that explain the state/scenario
- Examples: `ActiveUser`, `InactiveUser`, `NoStatus`, `Comparison`
- Avoid generic names like `Default`, `Example`, `Basic`

---

**üí° Remember:** The goal is to create focused, realistic, and maintainable component stories that serve as both documentation and testing tools. Always prioritize the component being documented over the complexity of its environment. Let Storybook handle titles automatically for consistency. 