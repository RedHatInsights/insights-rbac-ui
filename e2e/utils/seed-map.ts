/**
 * Seed Map Loader Utility
 *
 * Safely loads the seed-map-v1.json or seed-map-v2.json file generated by the CLI seeder.
 * Returns an empty structure if the file doesn't exist (tests should handle this gracefully).
 *
 * Version Detection:
 *   - Set TEST_VERSION=v1 or TEST_VERSION=v2 environment variable
 *   - Or pass version explicitly to functions
 *   - Defaults to v1 if not specified
 *
 * Also provides access to the seed fixture data (descriptions, permissions, etc.)
 *
 * Usage in tests:
 *   import { getSeedMap, getSeedFixture } from '../utils/seed-map';
 *   const seedMap = getSeedMap('v1');  // or 'v2'
 *   const fixture = getSeedFixture('v1');
 */
import * as fs from 'fs';
import { SEED_FILE_V1, SEED_FILE_V2, SEED_MAP_V1_PATH, SEED_MAP_V2_PATH } from './paths';

export type ApiVersion = 'v1' | 'v2';

/**
 * Get the current test version from environment or default to v1.
 */
export function getTestVersion(): ApiVersion {
  const envVersion = process.env.TEST_VERSION;
  if (envVersion === 'v1' || envVersion === 'v2') {
    return envVersion;
  }
  return 'v1';
}

/**
 * Get the seed map path for a specific version.
 */
function getSeedMapPath(version: ApiVersion): string {
  return version === 'v2' ? SEED_MAP_V2_PATH : SEED_MAP_V1_PATH;
}

/**
 * Get the TEST_PREFIX for a specific version.
 */
function getTestPrefixForVersion(version: ApiVersion): string | undefined {
  return version === 'v2' ? process.env.TEST_PREFIX_V2 : process.env.TEST_PREFIX_V1;
}

export interface SeedMap {
  roles: Record<string, string>;
  groups: Record<string, string>;
  workspaces: Record<string, string>;
}

const EMPTY_SEED_MAP: SeedMap = {
  roles: {},
  groups: {},
  workspaces: {},
};

// ============================================================================
// Seed Fixture Types (the input JSON files)
// ============================================================================

export interface SeedPersonaInput {
  username: string;
}

export type PersonaType = 'admin' | 'userviewer' | 'readonly';

export interface SeedRoleInput {
  name: string;
  display_name?: string;
  description?: string;
  permissions?: string[];
}

export interface SeedGroupInput {
  name: string;
  description?: string;
}

export interface SeedWorkspaceInput {
  name: string;
  description?: string;
  parent_id?: string;
}

export interface SeededUserInput {
  username: string;
}

export interface SeedFixture {
  personas?: Partial<Record<PersonaType, SeedPersonaInput>>;
  seededUsers?: SeededUserInput[];
  roles?: SeedRoleInput[];
  groups?: SeedGroupInput[];
  workspaces?: SeedWorkspaceInput[];
}

const EMPTY_SEED_FIXTURE: SeedFixture = {
  personas: {},
  seededUsers: [],
  roles: [],
  groups: [],
  workspaces: [],
};

// Cache for seed fixture to avoid re-reading
let cachedSeedFixture: SeedFixture | null = null;
let cachedSeedFixtureVersion: 'v1' | 'v2' | null = null;

// Cache for seed maps to avoid re-reading
const seedMapCache: Record<ApiVersion, SeedMap | null> = { v1: null, v2: null };

/**
 * Load the seed map from disk for a specific version.
 * Returns an empty seed map if the file doesn't exist.
 */
export function getSeedMap(version?: ApiVersion): SeedMap {
  const v = version ?? getTestVersion();

  // Return cached if available
  if (seedMapCache[v]) {
    return seedMapCache[v]!;
  }

  const seedMapPath = getSeedMapPath(v);

  try {
    if (!fs.existsSync(seedMapPath)) {
      console.warn(`[SeedMap] seed-map-${v}.json not found. Run: npm run e2e:${v}:seed`);
      return EMPTY_SEED_MAP;
    }

    const content = fs.readFileSync(seedMapPath, 'utf-8');
    const parsed = JSON.parse(content) as SeedMap;

    // Validate structure
    if (!parsed.roles || !parsed.groups || !parsed.workspaces) {
      console.warn(`[SeedMap] Invalid seed-map-${v}.json structure`);
      return EMPTY_SEED_MAP;
    }

    seedMapCache[v] = parsed;
    return parsed;
  } catch (error) {
    console.warn(`[SeedMap] Failed to load seed-map-${v}.json:`, error);
    return EMPTY_SEED_MAP;
  }
}

/**
 * Check if the seed map has been populated with data.
 */
export function hasSeedData(version?: ApiVersion): boolean {
  const seedMap = getSeedMap(version);
  return Object.keys(seedMap.roles).length > 0 || Object.keys(seedMap.groups).length > 0 || Object.keys(seedMap.workspaces).length > 0;
}

/**
 * Get a specific role UUID from the seed map.
 * Returns undefined if not found.
 */
export function getRoleUuid(prefixedName: string, version?: ApiVersion): string | undefined {
  return getSeedMap(version).roles[prefixedName];
}

/**
 * Get a specific group UUID from the seed map.
 * Returns undefined if not found.
 */
export function getGroupUuid(prefixedName: string, version?: ApiVersion): string | undefined {
  return getSeedMap(version).groups[prefixedName];
}

/**
 * Get a specific workspace UUID from the seed map.
 * Returns undefined if not found.
 */
export function getWorkspaceUuid(prefixedName: string, version?: ApiVersion): string | undefined {
  return getSeedMap(version).workspaces[prefixedName];
}

/**
 * Get the first custom seeded role name (full prefixed name).
 * Filters for roles that start with the version-specific TEST_PREFIX.
 * Returns undefined if TEST_PREFIX_V1/V2 is not set or no matching roles found.
 */
export function getSeededRoleName(version?: ApiVersion): string | undefined {
  const v = version ?? getTestVersion();
  const prefix = getTestPrefixForVersion(v);
  if (!prefix) {
    console.warn(`[SeedMap] TEST_PREFIX_${v.toUpperCase()} not set, cannot find seeded role`);
    return undefined;
  }

  const names = Object.keys(getSeedMap(v).roles);
  const matchingNames = names.filter((name) => name.startsWith(`${prefix}__`));
  return matchingNames.length > 0 ? matchingNames[0] : undefined;
}

/**
 * Get the first custom seeded group name (full prefixed name).
 * Filters for groups that start with the version-specific TEST_PREFIX.
 * Returns undefined if TEST_PREFIX_V1/V2 is not set or no matching groups found.
 */
export function getSeededGroupName(version?: ApiVersion): string | undefined {
  const v = version ?? getTestVersion();
  const prefix = getTestPrefixForVersion(v);
  if (!prefix) {
    console.warn(`[SeedMap] TEST_PREFIX_${v.toUpperCase()} not set, cannot find seeded group`);
    return undefined;
  }

  const names = Object.keys(getSeedMap(v).groups);
  const matchingNames = names.filter((name) => name.startsWith(`${prefix}__`));
  return matchingNames.length > 0 ? matchingNames[0] : undefined;
}

/**
 * Get the first custom seeded workspace name (full prefixed name).
 * Filters for workspaces that start with the version-specific TEST_PREFIX.
 * Returns undefined if TEST_PREFIX_V1/V2 is not set or no matching workspaces found.
 */
export function getSeededWorkspaceName(version?: ApiVersion): string | undefined {
  const v = version ?? getTestVersion();
  const prefix = getTestPrefixForVersion(v);
  if (!prefix) {
    console.warn(`[SeedMap] TEST_PREFIX_${v.toUpperCase()} not set, cannot find seeded workspace`);
    return undefined;
  }

  const names = Object.keys(getSeedMap(v).workspaces);
  const matchingNames = names.filter((name) => name.startsWith(`${prefix}__`));
  return matchingNames.length > 0 ? matchingNames[0] : undefined;
}

// ============================================================================
// Seed Fixture Loaders (for accessing descriptions, permissions, etc.)
// ============================================================================

/**
 * Load the seed fixture file.
 * Automatically detects V1 vs V2 based on which file exists and has content.
 * Returns empty fixture if neither exists.
 */
export function getSeedFixture(version?: 'v1' | 'v2'): SeedFixture {
  // Return cached if available and version matches
  if (cachedSeedFixture && (!version || version === cachedSeedFixtureVersion)) {
    return cachedSeedFixture;
  }

  const seedFile = version === 'v2' ? SEED_FILE_V2 : SEED_FILE_V1;

  try {
    if (!fs.existsSync(seedFile)) {
      // Try the other version
      const altFile = version === 'v2' ? SEED_FILE_V1 : SEED_FILE_V2;
      if (fs.existsSync(altFile)) {
        const content = fs.readFileSync(altFile, 'utf-8');
        cachedSeedFixture = JSON.parse(content) as SeedFixture;
        cachedSeedFixtureVersion = version === 'v2' ? 'v1' : 'v2';
        return cachedSeedFixture;
      }
      console.warn('[SeedFixture] No seed fixture file found');
      return EMPTY_SEED_FIXTURE;
    }

    const content = fs.readFileSync(seedFile, 'utf-8');
    cachedSeedFixture = JSON.parse(content) as SeedFixture;
    cachedSeedFixtureVersion = version || 'v1';
    return cachedSeedFixture;
  } catch (error) {
    console.warn('[SeedFixture] Failed to load seed fixture:', error);
    return EMPTY_SEED_FIXTURE;
  }
}

/**
 * Get the seeded role's metadata (description, permissions, etc.)
 * Returns undefined if no seeded role exists.
 */
export function getSeededRoleData(): SeedRoleInput | undefined {
  const fixture = getSeedFixture();
  return fixture.roles?.[0];
}

/**
 * Get the seeded group's metadata (description, etc.)
 * Returns undefined if no seeded group exists.
 */
export function getSeededGroupData(): SeedGroupInput | undefined {
  const fixture = getSeedFixture();
  return fixture.groups?.[0];
}

/**
 * Get the seeded workspace's metadata (description, etc.)
 * Returns undefined if no seeded workspace exists.
 */
export function getSeededWorkspaceData(version?: ApiVersion): SeedWorkspaceInput | undefined {
  const fixture = getSeedFixture(version);
  return fixture.workspaces?.[0];
}

// ============================================================================
// Seeded Users Helpers
// ============================================================================

/**
 * Get the list of seeded user usernames from the seed fixture.
 * Seeded users are pre-existing stage accounts used as test data.
 * They are NOT personas (which are auth-linked accounts for running tests).
 */
export function getSeededUsernames(version?: 'v1' | 'v2'): string[] {
  const fixture = getSeedFixture(version);
  return (fixture.seededUsers ?? []).map((u) => u.username);
}

/**
 * Get a single seeded user username by index (default: first).
 * Returns undefined if no seeded users are defined.
 */
export function getSeededUsername(index = 0, version?: 'v1' | 'v2'): string | undefined {
  return getSeededUsernames(version)[index];
}
