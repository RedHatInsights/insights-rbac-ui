/**
 * Seed Map Loader Utility
 *
 * Safely loads the seed-map.json file generated by the CLI seeder.
 * Returns an empty structure if the file doesn't exist (tests should handle this gracefully).
 *
 * Also provides access to the seed fixture data (descriptions, permissions, etc.)
 *
 * Usage in tests:
 *   import { getSeedMap, getSeedFixture } from '../utils/seed-map';
 *   const seedMap = getSeedMap();
 *   const fixture = getSeedFixture();
 */
import * as fs from 'fs';
import { SEED_FILE_V1, SEED_FILE_V2, SEED_MAP_PATH } from './paths';

export interface SeedMap {
  roles: Record<string, string>;
  groups: Record<string, string>;
  workspaces: Record<string, string>;
}

const EMPTY_SEED_MAP: SeedMap = {
  roles: {},
  groups: {},
  workspaces: {},
};

// ============================================================================
// Seed Fixture Types (the input JSON files)
// ============================================================================

export interface SeedRoleInput {
  name: string;
  display_name?: string;
  description?: string;
  permissions?: string[];
}

export interface SeedGroupInput {
  name: string;
  description?: string;
}

export interface SeedWorkspaceInput {
  name: string;
  description?: string;
  parent_id?: string;
}

export interface SeedFixture {
  roles?: SeedRoleInput[];
  groups?: SeedGroupInput[];
  workspaces?: SeedWorkspaceInput[];
}

const EMPTY_SEED_FIXTURE: SeedFixture = {
  roles: [],
  groups: [],
  workspaces: [],
};

// Cache for seed fixture to avoid re-reading
let cachedSeedFixture: SeedFixture | null = null;
let cachedSeedFixtureVersion: 'v1' | 'v2' | null = null;

/**
 * Load the seed map from disk.
 * Returns an empty seed map if the file doesn't exist.
 */
export function getSeedMap(): SeedMap {
  try {
    if (!fs.existsSync(SEED_MAP_PATH)) {
      console.warn('[SeedMap] seed-map.json not found. Run: npm run e2e:seed');
      return EMPTY_SEED_MAP;
    }

    const content = fs.readFileSync(SEED_MAP_PATH, 'utf-8');
    const parsed = JSON.parse(content) as SeedMap;

    // Validate structure
    if (!parsed.roles || !parsed.groups || !parsed.workspaces) {
      console.warn('[SeedMap] Invalid seed-map.json structure');
      return EMPTY_SEED_MAP;
    }

    return parsed;
  } catch (error) {
    console.warn('[SeedMap] Failed to load seed-map.json:', error);
    return EMPTY_SEED_MAP;
  }
}

/**
 * Check if the seed map has been populated with data.
 */
export function hasSeedData(): boolean {
  const seedMap = getSeedMap();
  return Object.keys(seedMap.roles).length > 0 || Object.keys(seedMap.groups).length > 0 || Object.keys(seedMap.workspaces).length > 0;
}

/**
 * Get a specific role UUID from the seed map.
 * Returns undefined if not found.
 */
export function getRoleUuid(prefixedName: string): string | undefined {
  return getSeedMap().roles[prefixedName];
}

/**
 * Get a specific group UUID from the seed map.
 * Returns undefined if not found.
 */
export function getGroupUuid(prefixedName: string): string | undefined {
  return getSeedMap().groups[prefixedName];
}

/**
 * Get a specific workspace UUID from the seed map.
 * Returns undefined if not found.
 */
export function getWorkspaceUuid(prefixedName: string): string | undefined {
  return getSeedMap().workspaces[prefixedName];
}

/**
 * Get the TEST_PREFIX from environment.
 * Returns undefined if not set.
 */
function getTestPrefix(): string | undefined {
  return process.env.TEST_PREFIX;
}

/**
 * Get the first custom seeded role name (full prefixed name).
 * Filters for roles that start with the TEST_PREFIX.
 * Returns undefined if TEST_PREFIX is not set or no matching roles found.
 */
export function getSeededRoleName(): string | undefined {
  const prefix = getTestPrefix();
  if (!prefix) {
    console.warn('[SeedMap] TEST_PREFIX not set, cannot find seeded role');
    return undefined;
  }

  const names = Object.keys(getSeedMap().roles);
  const matchingNames = names.filter((name) => name.startsWith(`${prefix}__`));
  return matchingNames.length > 0 ? matchingNames[0] : undefined;
}

/**
 * Get the first custom seeded group name (full prefixed name).
 * Filters for groups that start with the TEST_PREFIX.
 * Returns undefined if TEST_PREFIX is not set or no matching groups found.
 */
export function getSeededGroupName(): string | undefined {
  const prefix = getTestPrefix();
  if (!prefix) {
    console.warn('[SeedMap] TEST_PREFIX not set, cannot find seeded group');
    return undefined;
  }

  const names = Object.keys(getSeedMap().groups);
  const matchingNames = names.filter((name) => name.startsWith(`${prefix}__`));
  return matchingNames.length > 0 ? matchingNames[0] : undefined;
}

/**
 * Get the first custom seeded workspace name (full prefixed name).
 * Filters for workspaces that start with the TEST_PREFIX.
 * Returns undefined if TEST_PREFIX is not set or no matching workspaces found.
 */
export function getSeededWorkspaceName(): string | undefined {
  const prefix = getTestPrefix();
  if (!prefix) {
    console.warn('[SeedMap] TEST_PREFIX not set, cannot find seeded workspace');
    return undefined;
  }

  const names = Object.keys(getSeedMap().workspaces);
  const matchingNames = names.filter((name) => name.startsWith(`${prefix}__`));
  return matchingNames.length > 0 ? matchingNames[0] : undefined;
}

// ============================================================================
// Seed Fixture Loaders (for accessing descriptions, permissions, etc.)
// ============================================================================

/**
 * Load the seed fixture file.
 * Automatically detects V1 vs V2 based on which file exists and has content.
 * Returns empty fixture if neither exists.
 */
export function getSeedFixture(version?: 'v1' | 'v2'): SeedFixture {
  // Return cached if available and version matches
  if (cachedSeedFixture && (!version || version === cachedSeedFixtureVersion)) {
    return cachedSeedFixture;
  }

  const seedFile = version === 'v2' ? SEED_FILE_V2 : SEED_FILE_V1;

  try {
    if (!fs.existsSync(seedFile)) {
      // Try the other version
      const altFile = version === 'v2' ? SEED_FILE_V1 : SEED_FILE_V2;
      if (fs.existsSync(altFile)) {
        const content = fs.readFileSync(altFile, 'utf-8');
        cachedSeedFixture = JSON.parse(content) as SeedFixture;
        cachedSeedFixtureVersion = version === 'v2' ? 'v1' : 'v2';
        return cachedSeedFixture;
      }
      console.warn('[SeedFixture] No seed fixture file found');
      return EMPTY_SEED_FIXTURE;
    }

    const content = fs.readFileSync(seedFile, 'utf-8');
    cachedSeedFixture = JSON.parse(content) as SeedFixture;
    cachedSeedFixtureVersion = version || 'v1';
    return cachedSeedFixture;
  } catch (error) {
    console.warn('[SeedFixture] Failed to load seed fixture:', error);
    return EMPTY_SEED_FIXTURE;
  }
}

/**
 * Get the seeded role's metadata (description, permissions, etc.)
 * Returns undefined if no seeded role exists.
 */
export function getSeededRoleData(): SeedRoleInput | undefined {
  const fixture = getSeedFixture();
  return fixture.roles?.[0];
}

/**
 * Get the seeded group's metadata (description, etc.)
 * Returns undefined if no seeded group exists.
 */
export function getSeededGroupData(): SeedGroupInput | undefined {
  const fixture = getSeedFixture();
  return fixture.groups?.[0];
}

/**
 * Get the seeded workspace's metadata (description, etc.)
 * Returns undefined if no seeded workspace exists.
 */
export function getSeededWorkspaceData(): SeedWorkspaceInput | undefined {
  const fixture = getSeedFixture();
  return fixture.workspaces?.[0];
}
